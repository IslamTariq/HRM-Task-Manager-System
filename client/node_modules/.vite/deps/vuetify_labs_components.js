import {
  VColorPicker,
  VConfirmEdit,
  VExpansionPanel,
  VExpansionPanels,
  VKbd,
  VSlider,
  VStepperActions,
  makeFileFilterProps,
  makeStepperItemProps,
  makeStepperProps,
  makeVColorPickerProps,
  makeVConfirmEditProps,
  makeVExpansionPanelProps,
  makeVExpansionPanelsProps,
  makeVStepperActionsProps,
  useFileDrop,
  useFileFilter
} from "./chunk-OND52UYG.js";
import {
  VDatePicker,
  VPicker,
  VPickerTitle,
  VSheet,
  makeVDatePickerProps,
  makeVSheetProps
} from "./chunk-5NB276JB.js";
import {
  VChip,
  VChipGroup
} from "./chunk-TMBDB5NX.js";
import {
  VMenu
} from "./chunk-2CPOCRQ2.js";
import {
  makeIconSizeProps,
  useIconSizes
} from "./chunk-NSD7JLVT.js";
import "./chunk-MVBFAXEB.js";
import {
  VSpacer
} from "./chunk-HOZNDGDO.js";
import {
  VTextField,
  makeVTextFieldProps
} from "./chunk-TC4CYBPA.js";
import "./chunk-EHIOY3IW.js";
import {
  makeFocusProps
} from "./chunk-2RFHOBRP.js";
import "./chunk-LX3LEMYR.js";
import {
  VListItem,
  makeVListItemProps
} from "./chunk-MF5RIT44.js";
import {
  VAvatar
} from "./chunk-NJV7VNWN.js";
import {
  VDivider,
  makeVDividerProps
} from "./chunk-5FQFQMPH.js";
import {
  isMaskDelimiter,
  makeMaskProps,
  splitKeyCombination,
  splitKeySequence,
  useMask
} from "./chunk-F6VS3EMP.js";
import {
  createDateRange,
  useDate
} from "./chunk-KCF3A5K7.js";
import "./chunk-PAOG32ZX.js";
import {
  resize_default,
  tooltip_default
} from "./chunk-WASTU3RZ.js";
import {
  VTooltip,
  makeVTooltipProps
} from "./chunk-XDCIU5SR.js";
import {
  VOverlay,
  click_outside_default
} from "./chunk-3RFNW3J6.js";
import {
  makeDelayProps
} from "./chunk-VOQM64TW.js";
import {
  forwardRefs
} from "./chunk-CTPTHNTO.js";
import {
  makeDisplayProps,
  useDisplay
} from "./chunk-NBDWK5LD.js";
import {
  VBtn
} from "./chunk-522YE5QA.js";
import {
  VProgressCircular
} from "./chunk-M3QWHI6W.js";
import "./chunk-CCXYPEAH.js";
import "./chunk-KGKFM23D.js";
import "./chunk-4EYEBK3Y.js";
import "./chunk-JXUOHERI.js";
import "./chunk-2RB7BEQ5.js";
import {
  makeDensityProps,
  useDensity
} from "./chunk-DRFLE747.js";
import {
  VFadeTransition
} from "./chunk-ELA2RYDN.js";
import {
  makeElevationProps,
  useElevation
} from "./chunk-AVVOBQLD.js";
import {
  genOverlays,
  makeVariantProps,
  useVariant
} from "./chunk-WF77UYQG.js";
import {
  makeBorderProps,
  useBorder
} from "./chunk-AAC72PH4.js";
import "./chunk-DXNRQCE6.js";
import {
  VDefaultsProvider
} from "./chunk-6ZXH6I6Q.js";
import {
  VImg
} from "./chunk-NRETZ6KB.js";
import "./chunk-BKARBUUQ.js";
import "./chunk-PRMJHUHT.js";
import {
  makeRoundedProps,
  useRounded
} from "./chunk-HFFBQQOH.js";
import {
  VIcon
} from "./chunk-4Y4JIOCV.js";
import {
  makeTagProps
} from "./chunk-7JPJIKOB.js";
import {
  IconValue
} from "./chunk-DQJYALFG.js";
import {
  ripple_default
} from "./chunk-UFQGHWRY.js";
import "./chunk-BTGBN3E2.js";
import "./chunk-IDSOM72Y.js";
import {
  MaybeTransition,
  makeTransitionProps
} from "./chunk-CMXH63KR.js";
import {
  makeDimensionProps,
  useDimension
} from "./chunk-VSM7OQFH.js";
import {
  computeColor,
  useBackgroundColor,
  useColor
} from "./chunk-MSZH4BGX.js";
import "./chunk-WYI57K6O.js";
import "./chunk-2OYR7IGZ.js";
import {
  provideLocale,
  useLocale,
  useRtl
} from "./chunk-BMA4JMJ6.js";
import {
  useProxiedModel
} from "./chunk-R5A7ZBOE.js";
import {
  makeThemeProps,
  provideTheme,
  useTheme
} from "./chunk-OGNRBNJ4.js";
import {
  EventProp,
  clamp,
  consoleWarn,
  convertToUnit,
  createRange,
  defineComponent,
  easingPatterns,
  filterInputAttrs,
  formatTime,
  genericComponent,
  getPrefixedEventHandlers,
  getPropertyFromItem,
  getScrollParents,
  humanReadableFileSize,
  makeComponentProps,
  mergeDeep,
  omit,
  pick,
  propsFactory,
  provideDefaults,
  useRender,
  useTransition,
  wrapInArray
} from "./chunk-AY45HN4E.js";
import {
  Fragment,
  Transition,
  computed,
  createBaseVNode,
  createTextVNode,
  createVNode,
  mergeProps,
  nextTick,
  normalizeClass,
  normalizeStyle,
  onBeforeMount,
  onBeforeUnmount,
  onMounted,
  onUpdated,
  reactive,
  ref,
  shallowRef,
  toDisplayString,
  toRef,
  toRefs,
  toValue,
  watch,
  watchEffect,
  withDirectives
} from "./chunk-LG6AQRJS.js";
import "./chunk-PZ5AY32C.js";

// node_modules/vuetify/lib/labs/VCalendar/VCalendar.js
import "C:/Users/islam/source/HRMS/client/node_modules/vuetify/lib/labs/VCalendar/VCalendarCategory.css";
import "C:/Users/islam/source/HRMS/client/node_modules/vuetify/lib/labs/VCalendar/VCalendarDaily.css";
import "C:/Users/islam/source/HRMS/client/node_modules/vuetify/lib/labs/VCalendar/VCalendarWeekly.css";

// node_modules/vuetify/lib/labs/VIconBtn/VIconBtn.js
import "C:/Users/islam/source/HRMS/client/node_modules/vuetify/lib/labs/VIconBtn/VIconBtn.css";
var makeVIconBtnProps = propsFactory({
  active: {
    type: Boolean,
    default: void 0
  },
  activeColor: String,
  activeIcon: [String, Function, Object],
  activeVariant: String,
  baseVariant: {
    type: String,
    default: "tonal"
  },
  disabled: Boolean,
  height: [Number, String],
  width: [Number, String],
  hideOverlay: Boolean,
  icon: [String, Function, Object],
  iconColor: String,
  loading: Boolean,
  opacity: [Number, String],
  readonly: Boolean,
  rotate: [Number, String],
  size: {
    type: [Number, String],
    default: "default"
  },
  sizes: {
    type: Array,
    default: () => [["x-small", 16], ["small", 24], ["default", 40], ["large", 48], ["x-large", 56]]
  },
  text: {
    type: [String, Number, Boolean],
    default: void 0
  },
  ...makeBorderProps(),
  ...makeComponentProps(),
  ...makeElevationProps(),
  ...makeIconSizeProps(),
  ...makeRoundedProps(),
  ...makeTagProps({
    tag: "button"
  }),
  ...makeThemeProps(),
  ...makeVariantProps({
    variant: "flat"
  })
}, "VIconBtn");
var VIconBtn = genericComponent()({
  name: "VIconBtn",
  props: makeVIconBtnProps(),
  emits: {
    "update:active": (value) => true
  },
  setup(props, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const isActive = useProxiedModel(props, "active");
    const {
      themeClasses
    } = provideTheme(props);
    const {
      borderClasses
    } = useBorder(props);
    const {
      elevationClasses
    } = useElevation(props);
    const {
      roundedClasses
    } = useRounded(props);
    const {
      colorClasses,
      colorStyles,
      variantClasses
    } = useVariant(() => ({
      color: (() => {
        if (props.disabled) return void 0;
        if (!isActive.value) return props.color;
        return props.activeColor ?? props.color ?? "surface-variant";
      })(),
      variant: (() => {
        if (isActive.value === void 0) return props.variant;
        if (isActive.value) return props.activeVariant ?? props.variant;
        return props.baseVariant ?? props.variant;
      })()
    }));
    const btnSizeMap = new Map(props.sizes);
    function onClick() {
      if (props.disabled || props.readonly || isActive.value === void 0 || props.tag === "a" && attrs.href) return;
      isActive.value = !isActive.value;
    }
    useRender(() => {
      const icon = isActive.value ? props.activeIcon ?? props.icon : props.icon;
      const _btnSize = props.size;
      const hasNamedSize = btnSizeMap.has(_btnSize);
      const btnSize = hasNamedSize ? btnSizeMap.get(_btnSize) : _btnSize;
      const btnHeight = props.height ?? btnSize;
      const btnWidth = props.width ?? btnSize;
      const {
        iconSize
      } = useIconSizes(props, () => new Map(props.iconSizes).get(_btnSize));
      const iconProps = {
        icon,
        size: iconSize.value,
        color: props.iconColor,
        opacity: props.opacity
      };
      return createVNode(props.tag, {
        "type": props.tag === "button" ? "button" : void 0,
        "class": normalizeClass([{
          "v-icon-btn": true,
          "v-icon-btn--active": isActive.value,
          "v-icon-btn--disabled": props.disabled,
          "v-icon-btn--loading": props.loading,
          "v-icon-btn--readonly": props.readonly,
          [`v-icon-btn--${props.size}`]: true
        }, themeClasses.value, colorClasses.value, borderClasses.value, elevationClasses.value, roundedClasses.value, variantClasses.value, props.class]),
        "style": normalizeStyle([{
          "--v-icon-btn-rotate": convertToUnit(props.rotate, "deg"),
          "--v-icon-btn-height": convertToUnit(btnHeight),
          "--v-icon-btn-width": convertToUnit(btnWidth)
        }, colorStyles.value, props.style]),
        "tabindex": props.disabled || props.readonly ? -1 : 0,
        "onClick": onClick
      }, {
        default: () => [genOverlays(!props.hideOverlay, "v-icon-btn"), createBaseVNode("div", {
          "class": "v-icon-btn__content",
          "data-no-activator": ""
        }, [!slots.default && icon ? createVNode(VIcon, mergeProps({
          "key": "content-icon"
        }, iconProps), null) : createVNode(VDefaultsProvider, {
          "key": "content-defaults",
          "disabled": !icon,
          "defaults": {
            VIcon: {
              ...iconProps
            }
          }
        }, {
          default: () => slots.default?.() ?? toDisplayString(props.text)
        })]), !!props.loading && createBaseVNode("span", {
          "key": "loader",
          "class": "v-icon-btn__loader"
        }, [slots.loader?.() ?? createVNode(VProgressCircular, {
          "color": typeof props.loading === "boolean" ? void 0 : props.loading,
          "indeterminate": "disable-shrink",
          "width": "2",
          "size": iconSize.value
        }, null)])]
      });
    });
    return {};
  }
});

// node_modules/vuetify/lib/labs/VCalendar/util/dateTimeUtils.js
function createUTCDate(year) {
  let month = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  let day = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
  let date;
  if (year < 100 && year >= 0) {
    date = new Date(Date.UTC(year, month, day));
    if (isFinite(date.getUTCFullYear())) {
      date.setUTCFullYear(year);
    }
  } else {
    date = new Date(Date.UTC(year, month, day));
  }
  return date;
}
function firstWeekOffset(year, firstDayOfWeek, firstDayOfYear) {
  const firstWeekDayInFirstWeek = 7 + firstDayOfWeek - firstDayOfYear;
  const firstWeekDayOfYear = (7 + createUTCDate(year, 0, firstWeekDayInFirstWeek).getUTCDay() - firstDayOfWeek) % 7;
  return -firstWeekDayOfYear + firstWeekDayInFirstWeek - 1;
}
function dayOfYear(year, month, day, firstDayOfWeek) {
  let dayOfYear2 = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334][month];
  if (month > 1 && isLeapYear(year)) {
    dayOfYear2++;
  }
  return dayOfYear2 + day;
}
function weeksInYear(year, firstDayOfWeek, firstDayOfYear) {
  const weekOffset = firstWeekOffset(year, firstDayOfWeek, firstDayOfYear);
  const weekOffsetNext = firstWeekOffset(year + 1, firstDayOfWeek, firstDayOfYear);
  const daysInYear = isLeapYear(year) ? 366 : 365;
  return (daysInYear - weekOffset + weekOffsetNext) / 7;
}
function weekNumber(year, month, day, firstDayOfWeek, localeFirstDayOfYear) {
  const weekOffset = firstWeekOffset(year, firstDayOfWeek, localeFirstDayOfYear);
  const week = Math.ceil((dayOfYear(year, month, day, firstDayOfWeek) - weekOffset) / 7);
  if (week < 1) {
    return week + weeksInYear(year - 1, firstDayOfWeek, localeFirstDayOfYear);
  } else if (week > weeksInYear(year, firstDayOfWeek, localeFirstDayOfYear)) {
    return week - weeksInYear(year, firstDayOfWeek, localeFirstDayOfYear);
  } else {
    return week;
  }
}
function isLeapYear(year) {
  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
}

// node_modules/vuetify/lib/labs/VCalendar/util/timestamp.js
var PARSE_REGEX = /^(\d{4})-(\d{1,2})(-(\d{1,2}))?([^\d]+(\d{1,2}))?(:(\d{1,2}))?(:(\d{1,2}))?$/;
var PARSE_TIME = /(\d\d?)(:(\d\d?)|)(:(\d\d?)|)/;
var DAYS_IN_MONTH = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var DAYS_IN_MONTH_LEAP = [0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var DAYS_IN_MONTH_MIN = 28;
var DAYS_IN_MONTH_MAX = 31;
var MONTH_MAX = 12;
var MONTH_MIN = 1;
var DAY_MIN = 1;
var DAYS_IN_WEEK = 7;
var MINUTES_IN_HOUR = 60;
var MINUTE_MAX = 59;
var MINUTES_IN_DAY = 24 * 60;
var HOUR_MAX = 23;
var OFFSET_YEAR = 1e4;
var OFFSET_MONTH = 100;
var OFFSET_HOUR = 100;
var OFFSET_TIME = 1e4;
function getStartOfWeek(timestamp, weekdays, today) {
  const start = copyTimestamp(timestamp);
  findWeekday(start, weekdays[0], prevDay);
  updateFormatted(start);
  if (today) {
    updateRelative(start, today, start.hasTime);
  }
  return start;
}
function getEndOfWeek(timestamp, weekdays, today) {
  const end = copyTimestamp(timestamp);
  findWeekday(end, weekdays[weekdays.length - 1]);
  updateFormatted(end);
  if (today) {
    updateRelative(end, today, end.hasTime);
  }
  return end;
}
function getStartOfMonth(timestamp) {
  const start = copyTimestamp(timestamp);
  start.day = DAY_MIN;
  updateWeekday(start);
  updateFormatted(start);
  return start;
}
function getEndOfMonth(timestamp) {
  const end = copyTimestamp(timestamp);
  end.day = daysInMonth(end.year, end.month);
  updateWeekday(end);
  updateFormatted(end);
  return end;
}
function validateNumber(input) {
  return isFinite(parseInt(input));
}
function validateTime(input) {
  return typeof input === "number" && isFinite(input) || !!PARSE_TIME.exec(input) || typeof input === "object" && isFinite(input.hour) && isFinite(input.minute);
}
function parseTime(input) {
  if (typeof input === "number") {
    return input;
  } else if (typeof input === "string") {
    const parts = PARSE_TIME.exec(input);
    if (!parts) {
      return false;
    }
    return parseInt(parts[1]) * 60 + parseInt(parts[3] || 0);
  } else if (typeof input === "object") {
    if (typeof input.hour !== "number" || typeof input.minute !== "number") {
      return false;
    }
    return input.hour * 60 + input.minute;
  } else {
    return false;
  }
}
function validateTimestamp(input) {
  return typeof input === "number" && isFinite(input) || typeof input === "string" && !!PARSE_REGEX.exec(input) || input instanceof Date;
}
function parseTimestamp(input) {
  let required = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  let now = arguments.length > 2 ? arguments[2] : void 0;
  if (typeof input === "number" && isFinite(input)) {
    input = new Date(input);
  }
  if (input instanceof Date) {
    const date = parseDate(input);
    if (now) {
      updateRelative(date, now, date.hasTime);
    }
    return date;
  }
  if (typeof input !== "string") {
    if (required) {
      throw new Error(`${input} is not a valid timestamp. It must be a Date, number of milliseconds since Epoch, or a string in the format of YYYY-MM-DD or YYYY-MM-DD hh:mm. Zero-padding is optional and seconds are ignored.`);
    }
    return null;
  }
  const parts = PARSE_REGEX.exec(input);
  if (!parts) {
    if (required) {
      throw new Error(`${input} is not a valid timestamp. It must be a Date, number of milliseconds since Epoch, or a string in the format of YYYY-MM-DD or YYYY-MM-DD hh:mm. Zero-padding is optional and seconds are ignored.`);
    }
    return null;
  }
  const timestamp = {
    date: input,
    time: "",
    year: parseInt(parts[1]),
    month: parseInt(parts[2]),
    day: parseInt(parts[4]) || 1,
    hour: parseInt(parts[6]) || 0,
    minute: parseInt(parts[8]) || 0,
    weekday: 0,
    hasDay: !!parts[4],
    hasTime: !!(parts[6] && parts[8]),
    past: false,
    present: false,
    future: false
  };
  updateWeekday(timestamp);
  updateFormatted(timestamp);
  if (now) {
    updateRelative(timestamp, now, timestamp.hasTime);
  }
  return timestamp;
}
function parseDate(date) {
  return updateFormatted({
    date: "",
    time: "",
    year: date.getFullYear(),
    month: date.getMonth() + 1,
    day: date.getDate(),
    weekday: date.getDay(),
    hour: date.getHours(),
    minute: date.getMinutes(),
    hasDay: true,
    hasTime: true,
    past: false,
    present: true,
    future: false
  });
}
function getDayIdentifier(timestamp) {
  return timestamp.year * OFFSET_YEAR + timestamp.month * OFFSET_MONTH + timestamp.day;
}
function getTimeIdentifier(timestamp) {
  return timestamp.hour * OFFSET_HOUR + timestamp.minute;
}
function getTimestampIdentifier(timestamp) {
  return getDayIdentifier(timestamp) * OFFSET_TIME + getTimeIdentifier(timestamp);
}
function updateRelative(timestamp, now) {
  let time = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  let a = getDayIdentifier(now);
  let b = getDayIdentifier(timestamp);
  let present = a === b;
  if (timestamp.hasTime && time && present) {
    a = getTimeIdentifier(now);
    b = getTimeIdentifier(timestamp);
    present = a === b;
  }
  timestamp.past = b < a;
  timestamp.present = present;
  timestamp.future = b > a;
  return timestamp;
}
function isTimedless(input) {
  return input instanceof Date || typeof input === "number" && isFinite(input);
}
function updateHasTime(timestamp, hasTime, now) {
  if (timestamp.hasTime !== hasTime) {
    timestamp.hasTime = hasTime;
    if (!hasTime) {
      timestamp.hour = HOUR_MAX;
      timestamp.minute = MINUTE_MAX;
      timestamp.time = getTime(timestamp);
    }
    if (now) {
      updateRelative(timestamp, now, timestamp.hasTime);
    }
  }
  return timestamp;
}
function updateMinutes(timestamp, minutes, now) {
  timestamp.hasTime = true;
  timestamp.hour = Math.floor(minutes / MINUTES_IN_HOUR);
  timestamp.minute = minutes % MINUTES_IN_HOUR;
  timestamp.time = getTime(timestamp);
  if (now) {
    updateRelative(timestamp, now, true);
  }
  return timestamp;
}
function updateWeekday(timestamp) {
  timestamp.weekday = getWeekday(timestamp);
  return timestamp;
}
function updateFormatted(timestamp) {
  timestamp.time = getTime(timestamp);
  timestamp.date = getDate(timestamp);
  return timestamp;
}
function getWeekday(timestamp) {
  if (timestamp.hasDay) {
    const _ = Math.floor;
    const k = timestamp.day;
    const m = (timestamp.month + 9) % MONTH_MAX + 1;
    const C = _(timestamp.year / 100);
    const Y = timestamp.year % 100 - (timestamp.month <= 2 ? 1 : 0);
    return ((k + _(2.6 * m - 0.2) - 2 * C + Y + _(Y / 4) + _(C / 4)) % 7 + 7) % 7;
  }
  return timestamp.weekday;
}
function daysInMonth(year, month) {
  return isLeapYear(year) ? DAYS_IN_MONTH_LEAP[month] : DAYS_IN_MONTH[month];
}
function copyTimestamp(timestamp) {
  if (timestamp == null) return null;
  const {
    date,
    time,
    year,
    month,
    day,
    weekday,
    hour,
    minute,
    hasDay,
    hasTime,
    past,
    present,
    future
  } = timestamp;
  return {
    date,
    time,
    year,
    month,
    day,
    weekday,
    hour,
    minute,
    hasDay,
    hasTime,
    past,
    present,
    future
  };
}
function padNumber(x, length) {
  let padded = String(x);
  while (padded.length < length) {
    padded = "0" + padded;
  }
  return padded;
}
function getDate(timestamp) {
  let str = `${padNumber(timestamp.year, 4)}-${padNumber(timestamp.month, 2)}`;
  if (timestamp.hasDay) str += `-${padNumber(timestamp.day, 2)}`;
  return str;
}
function getTime(timestamp) {
  if (!timestamp.hasTime) {
    return "";
  }
  return `${padNumber(timestamp.hour, 2)}:${padNumber(timestamp.minute, 2)}`;
}
function nextDay(timestamp) {
  timestamp.day++;
  timestamp.weekday = (timestamp.weekday + 1) % DAYS_IN_WEEK;
  if (timestamp.day > DAYS_IN_MONTH_MIN && timestamp.day > daysInMonth(timestamp.year, timestamp.month)) {
    timestamp.day = DAY_MIN;
    timestamp.month++;
    if (timestamp.month > MONTH_MAX) {
      timestamp.month = MONTH_MIN;
      timestamp.year++;
    }
  }
  return timestamp;
}
function prevDay(timestamp) {
  timestamp.day--;
  timestamp.weekday = (timestamp.weekday + 6) % DAYS_IN_WEEK;
  if (timestamp.day < DAY_MIN) {
    timestamp.month--;
    if (timestamp.month < MONTH_MIN) {
      timestamp.year--;
      timestamp.month = MONTH_MAX;
    }
    timestamp.day = daysInMonth(timestamp.year, timestamp.month);
  }
  return timestamp;
}
function relativeDays(timestamp) {
  let mover = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : nextDay;
  let days = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
  while (--days >= 0) mover(timestamp);
  return timestamp;
}
function diffMinutes(min, max) {
  const Y = (max.year - min.year) * 525600;
  const M = (max.month - min.month) * 43800;
  const D = (max.day - min.day) * 1440;
  const h = (max.hour - min.hour) * 60;
  const m = max.minute - min.minute;
  return Y + M + D + h + m;
}
function findWeekday(timestamp, weekday) {
  let mover = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : nextDay;
  let maxDays = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 6;
  while (timestamp.weekday !== weekday && --maxDays >= 0) mover(timestamp);
  return timestamp;
}
function getWeekdaySkips(weekdays) {
  const skips = [1, 1, 1, 1, 1, 1, 1];
  const filled = [0, 0, 0, 0, 0, 0, 0];
  for (let i = 0; i < weekdays.length; i++) {
    filled[weekdays[i]] = 1;
  }
  for (let k = 0; k < DAYS_IN_WEEK; k++) {
    let skip = 1;
    for (let j = 1; j < DAYS_IN_WEEK; j++) {
      const next = (k + j) % DAYS_IN_WEEK;
      if (filled[next]) {
        break;
      }
      skip++;
    }
    skips[k] = filled[k] * skip;
  }
  return skips;
}
function timestampToDate(timestamp) {
  const time = `${padNumber(timestamp.hour, 2)}:${padNumber(timestamp.minute, 2)}`;
  const date = timestamp.date;
  return /* @__PURE__ */ new Date(`${date}T${time}:00+00:00`);
}
function createDayList(start, end, now, weekdaySkips) {
  let max = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 42;
  let min = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 0;
  const stop = getDayIdentifier(end);
  const days = [];
  let current = copyTimestamp(start);
  let currentIdentifier = 0;
  let stopped = currentIdentifier === stop;
  if (stop < getDayIdentifier(start)) {
    throw new Error("End date is earlier than start date.");
  }
  while ((!stopped || days.length < min) && days.length < max) {
    currentIdentifier = getDayIdentifier(current);
    stopped = stopped || currentIdentifier === stop;
    if (weekdaySkips[current.weekday] === 0) {
      current = nextDay(current);
      continue;
    }
    const day = copyTimestamp(current);
    updateFormatted(day);
    updateRelative(day, now);
    days.push(day);
    current = relativeDays(current, nextDay, weekdaySkips[current.weekday]);
  }
  if (!days.length) throw new Error("No dates found using specified start date, end date, and weekdays.");
  return days;
}
function createIntervalList(timestamp, first, minutes, count, now) {
  const intervals = [];
  for (let i = 0; i < count; i++) {
    const mins = first + i * minutes;
    const int = copyTimestamp(timestamp);
    intervals.push(updateMinutes(int, mins, now));
  }
  return intervals;
}
function createNativeLocaleFormatter(locale, getOptions) {
  const emptyFormatter = (_t, _s) => "";
  if (typeof Intl === "undefined" || typeof Intl.DateTimeFormat === "undefined") {
    return emptyFormatter;
  }
  return (timestamp, short) => {
    try {
      const intlFormatter = new Intl.DateTimeFormat(locale || void 0, getOptions(timestamp, short));
      return intlFormatter.format(timestampToDate(timestamp));
    } catch (e) {
      return "";
    }
  };
}
function validateWeekdays(input) {
  if (typeof input === "string") {
    input = input.split(",");
  }
  if (Array.isArray(input)) {
    const ints = input.map((x) => parseInt(x));
    if (ints.length > DAYS_IN_WEEK || ints.length === 0) {
      return false;
    }
    const visited = {};
    let wrapped = false;
    for (let i = 0; i < ints.length; i++) {
      const x = ints[i];
      if (!isFinite(x) || x < 0 || x >= DAYS_IN_WEEK) {
        return false;
      }
      if (i > 0) {
        const d = x - ints[i - 1];
        if (d < 0) {
          if (wrapped) {
            return false;
          }
          wrapped = true;
        } else if (d === 0) {
          return false;
        }
      }
      if (visited[x]) {
        return false;
      }
      visited[x] = true;
    }
    return true;
  }
  return false;
}

// node_modules/vuetify/lib/labs/VCalendar/composables/times.js
function useTimes(props) {
  const times = reactive({
    now: parseTimestamp("0000-00-00 00:00", true),
    today: parseTimestamp("0000-00-00", true)
  });
  const parsedNow = computed(() => {
    return props.now && validateTimestamp(props.now) ? parseTimestamp(props.now, true) : null;
  });
  function setPresent() {
    times.now.present = times.today.present = true;
    times.now.past = times.today.past = false;
    times.now.future = times.today.future = false;
  }
  function getNow() {
    return parseDate(/* @__PURE__ */ new Date());
  }
  function updateDay(now, target) {
    if (now.date !== target.date) {
      target.year = now.year;
      target.month = now.month;
      target.day = now.day;
      target.weekday = now.weekday;
      target.date = now.date;
    }
  }
  function updateTime(now, target) {
    if (now.time !== target.time) {
      target.hour = now.hour;
      target.minute = now.minute;
      target.time = now.time;
    }
  }
  function updateTimes() {
    const now = parsedNow.value || getNow();
    updateDay(now, times.now);
    updateTime(now, times.now);
    updateDay(now, times.today);
  }
  watch(parsedNow, updateTimes);
  updateTimes();
  setPresent();
  return {
    times,
    parsedNow,
    updateTimes,
    setPresent,
    getNow,
    updateDay,
    updateTime
  };
}

// node_modules/vuetify/lib/labs/VCalendar/composables/calendarBase.js
var makeCalendarBaseProps = propsFactory({
  start: {
    type: [String, Number, Date],
    validate: validateTimestamp,
    default: () => parseDate(/* @__PURE__ */ new Date()).date
  },
  end: {
    type: [String, Number, Date],
    validate: validateTimestamp
  },
  weekdays: {
    type: [Array, String],
    default: () => [0, 1, 2, 3, 4, 5, 6],
    validate: validateWeekdays
  },
  weekdayFormat: {
    type: Function,
    default: null
  },
  dayFormat: {
    type: Function,
    default: null
  },
  locale: String,
  now: {
    type: String,
    validator: validateTimestamp
  },
  type: {
    type: String,
    default: "month"
  }
}, "VCalendar-base");
function useCalendarBase(props) {
  const {
    times
  } = useTimes({
    now: props.now
  });
  const locale = provideLocale(props);
  const parsedStart = computed(() => {
    if (props.type === "month") {
      return getStartOfMonth(parseTimestamp(props.start, true));
    }
    return parseTimestamp(props.start, true);
  });
  const parsedEnd = computed(() => {
    const start = parsedStart.value;
    const end = props.end ? parseTimestamp(props.end) || start : start;
    const value = getTimestampIdentifier(end) < getTimestampIdentifier(start) ? start : end;
    if (props.type === "month") {
      return getEndOfMonth(value);
    }
    return value;
  });
  const parsedValue = computed(() => {
    return validateTimestamp(props.modelValue) ? parseTimestamp(props.modelValue, true) : parsedStart.value || times.today;
  });
  const parsedWeekdays = computed(() => {
    return Array.isArray(props.weekdays) ? props.weekdays : (props.weekdays || "").split(",").map((x) => parseInt(x, 10));
  });
  const effectiveWeekdays = computed(() => {
    const start = parsedValue.value;
    const days2 = parseInt(String(props.categoryDays)) || 1;
    switch (props.type) {
      case "day":
        return [start.weekday];
      case "4day":
        return [start.weekday, (start.weekday + 1) % 7, (start.weekday + 2) % 7, (start.weekday + 3) % 7];
      case "category":
        return Array.from({
          length: days2
        }, (_, i) => (start.weekday + i) % 7);
      default:
        return parsedWeekdays.value;
    }
  });
  const weekdaySkips = computed(() => {
    return getWeekdaySkips(parsedWeekdays.value);
  });
  const days = computed(() => {
    return createDayList(parsedStart.value, parsedEnd.value, times.today, weekdaySkips.value);
  });
  const dayFormatter = computed(() => {
    if (props.dayFormat) {
      return props.dayFormat;
    }
    return createNativeLocaleFormatter(locale.current.value, () => ({
      timeZone: "UTC",
      day: "numeric"
    }));
  });
  const weekdayFormatter = computed(() => {
    if (props.weekdayFormat) {
      return props.weekdayFormat;
    }
    return createNativeLocaleFormatter(locale.current.value, (_tms, short) => ({
      timeZone: "UTC",
      weekday: short ? "short" : "long"
    }));
  });
  function getColorProps(colors) {
    return computeColor(colors);
  }
  function getRelativeClasses(timestamp) {
    let outside = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    return {
      "v-present": timestamp.present,
      "v-past": timestamp.past,
      "v-future": timestamp.future,
      "v-outside": outside
    };
  }
  function _getStartOfWeek(timestamp) {
    return getStartOfWeek(timestamp, parsedWeekdays.value, times.today);
  }
  function _getEndOfWeek(timestamp) {
    return getEndOfWeek(timestamp, parsedWeekdays.value, times.today);
  }
  function getFormatter(options) {
    return createNativeLocaleFormatter(locale.current.value, () => options);
  }
  return {
    times,
    locale,
    parsedValue,
    parsedWeekdays,
    effectiveWeekdays,
    weekdaySkips,
    parsedStart,
    parsedEnd,
    days,
    dayFormatter,
    weekdayFormatter,
    getColorProps,
    getRelativeClasses,
    getStartOfWeek: _getStartOfWeek,
    getEndOfWeek: _getEndOfWeek,
    getFormatter
  };
}

// node_modules/vuetify/lib/labs/VCalendar/composables/calendarWithIntervals.js
var makeCalendarWithIntervalsProps = propsFactory({
  maxDays: {
    type: Number,
    default: 7
  },
  intervalHeight: {
    type: [Number, String],
    default: 48,
    validate: validateNumber
  },
  intervalWidth: {
    type: [Number, String],
    default: 60,
    validate: validateNumber
  },
  intervalMinutes: {
    type: [Number, String],
    default: 60,
    validate: validateNumber
  },
  firstInterval: {
    type: [Number, String],
    default: 0,
    validate: validateNumber
  },
  firstTime: {
    type: [Number, String, Object],
    validate: validateTime
  },
  intervalCount: {
    type: [Number, String],
    default: 24,
    validate: validateNumber
  },
  intervalFormat: {
    type: Function,
    default: null
  },
  intervalStyle: {
    type: Function,
    default: null
  },
  showIntervalLabel: {
    type: Function,
    default: null
  }
}, "VCalendar-intervals");
function useCalendarWithIntervals(props) {
  const base = useCalendarBase(props);
  const scrollAreaRef = shallowRef();
  const parsedFirstInterval = computed(() => {
    return parseInt(String(props.firstInterval || 0));
  });
  const parsedIntervalMinutes = computed(() => {
    return parseInt(String(props.intervalMinutes || 60));
  });
  const parsedIntervalCount = computed(() => {
    return parseInt(String(props.intervalCount || 24));
  });
  const parsedIntervalHeight = computed(() => {
    return parseFloat(String(props.intervalHeight || 48));
  });
  const parsedFirstTime = computed(() => {
    return parseTime(props.firstTime);
  });
  const firstMinute = computed(() => {
    const time = parsedFirstTime.value;
    return time !== false && time >= 0 && time <= MINUTES_IN_DAY ? time : parsedFirstInterval.value * parsedIntervalMinutes.value;
  });
  const bodyHeight = computed(() => {
    return parsedIntervalCount.value * parsedIntervalHeight.value;
  });
  const days = computed(() => {
    return createDayList(base.parsedStart.value, base.parsedEnd.value, base.times.today, base.weekdaySkips.value, props.maxDays);
  });
  const intervals = computed(() => {
    const daysValue = days.value;
    const first = firstMinute.value;
    const minutes = parsedIntervalMinutes.value;
    const count = parsedIntervalCount.value;
    const now = base.times.now;
    return daysValue.map((d) => createIntervalList(d, first, minutes, count, now));
  });
  const intervalFormatter = computed(() => {
    if (props.intervalFormat) {
      return props.intervalFormat;
    }
    return createNativeLocaleFormatter(base.locale.current.value, (tms, short) => !short ? {
      timeZone: "UTC",
      hour: "2-digit",
      minute: "2-digit"
    } : tms.minute === 0 ? {
      timeZone: "UTC",
      hour: "numeric"
    } : {
      timeZone: "UTC",
      hour: "numeric",
      minute: "2-digit"
    });
  });
  function showIntervalLabelDefault(interval) {
    const first = intervals.value[0][0];
    const isFirst = first.hour === interval.hour && first.minute === interval.minute;
    return !isFirst;
  }
  function intervalStyleDefault(_interval) {
    return void 0;
  }
  function getTimestampAtEvent(e, day) {
    const timestamp = copyTimestamp(day);
    const bounds = e.currentTarget.getBoundingClientRect();
    const baseMinutes = firstMinute.value;
    const touchEvent = e;
    const mouseEvent = e;
    const touches = touchEvent.changedTouches || touchEvent.touches;
    const clientY = touches && touches[0] ? touches[0].clientY : mouseEvent.clientY;
    const addIntervals = (clientY - bounds.top) / parsedIntervalHeight.value;
    const addMinutes = Math.floor(addIntervals * parsedIntervalMinutes.value);
    const minutes = baseMinutes + addMinutes;
    return updateMinutes(timestamp, minutes, base.times.now);
  }
  function getSlotScope(timestamp) {
    const scope = copyTimestamp(timestamp);
    scope.timeToY = timeToY;
    scope.timeDelta = timeDelta;
    scope.minutesToPixels = minutesToPixels;
    scope.week = days.value;
    return scope;
  }
  function scrollToTime(time) {
    const y = timeToY(time);
    const pane = scrollAreaRef.value;
    if (y === false || !pane) {
      return false;
    }
    pane.scrollTop = y;
    return true;
  }
  function minutesToPixels(minutes) {
    return minutes / parsedIntervalMinutes.value * parsedIntervalHeight.value;
  }
  function timeToY(time) {
    let clamp2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    let y = timeDelta(time);
    if (y !== false) {
      y *= bodyHeight.value;
      if (clamp2) {
        if (y < 0) {
          y = 0;
        }
        if (y > bodyHeight.value) {
          y = bodyHeight.value;
        }
      }
    }
    return y;
  }
  function timeDelta(time) {
    const minutes = parseTime(time);
    if (minutes === false) {
      return false;
    }
    const min = firstMinute.value;
    const gap = parsedIntervalCount.value * parsedIntervalMinutes.value;
    return (minutes - min) / gap;
  }
  return {
    ...base,
    scrollAreaRef,
    parsedFirstInterval,
    parsedIntervalMinutes,
    parsedIntervalCount,
    parsedIntervalHeight,
    parsedFirstTime,
    firstMinute,
    bodyHeight,
    days,
    intervals,
    intervalFormatter,
    showIntervalLabelDefault,
    intervalStyleDefault,
    getTimestampAtEvent,
    getSlotScope,
    scrollToTime,
    minutesToPixels,
    timeToY,
    timeDelta
  };
}

// node_modules/vuetify/lib/labs/VCalendar/VCalendarDaily.js
var VCalendarDaily = defineComponent({
  name: "VCalendarDaily",
  directives: {
    vResize: resize_default
  },
  props: {
    color: String,
    shortWeekdays: {
      type: Boolean,
      default: true
    },
    shortIntervals: {
      type: Boolean,
      default: true
    },
    hideHeader: Boolean,
    ...makeCalendarBaseProps(),
    ...makeCalendarWithIntervalsProps()
  },
  setup(props, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    const scrollPush = ref(0);
    const scrollArea = ref();
    const pane = ref();
    const base = useCalendarWithIntervals(props);
    function init() {
      nextTick(onResize);
    }
    function onResize() {
      scrollPush.value = getScrollPush();
    }
    function getScrollPush() {
      return scrollArea.value && pane.value ? scrollArea.value.offsetWidth - pane.value.offsetWidth : 0;
    }
    function genHead() {
      return createBaseVNode("div", {
        "class": "v-calendar-daily__head",
        "style": {
          marginRight: scrollPush.value + "px"
        }
      }, [genHeadIntervals(), genHeadDays()]);
    }
    function genHeadIntervals() {
      const width = convertToUnit(props.intervalWidth);
      return createBaseVNode("div", {
        "class": "v-calendar-daily__intervals-head",
        "style": {
          width
        }
      }, [slots["interval-header"]?.()]);
    }
    function genHeadDays() {
      return base.days.value.map(genHeadDay);
    }
    function genHeadDay(day, index) {
      const events = getPrefixedEventHandlers(attrs, ":day", (nativeEvent) => ({
        nativeEvent,
        ...base.getSlotScope(day)
      }));
      return createBaseVNode("div", mergeProps({
        "key": day.date,
        "class": ["v-calendar-daily_head-day", base.getRelativeClasses(day)]
      }, events), [genHeadWeekday(day), genHeadDayLabel(day), genDayHeader(day, index)]);
    }
    function genDayHeader(day, index) {
      return slots["day-header"]?.({
        week: base.days.value,
        ...day,
        index
      }) ?? [];
    }
    function genHeadWeekday(day) {
      const color = day.present ? props.color : void 0;
      return createBaseVNode("div", mergeProps(base.getColorProps({
        text: color
      }), {
        "class": "v-calendar-daily_head-weekday"
      }), [base.weekdayFormatter.value(day, props.shortWeekdays)]);
    }
    function genHeadDayLabel(day) {
      return createBaseVNode("div", {
        "class": "v-calendar-daily_head-day-label"
      }, [slots["day-label-header"]?.(day) ?? genHeadDayButton(day)]);
    }
    function genHeadDayButton(day) {
      const events = getPrefixedEventHandlers(attrs, ":date", (nativeEvent) => ({
        nativeEvent,
        ...day
      }));
      return createVNode(VIconBtn, mergeProps({
        "active": day.present,
        "activeColor": props.color,
        "variant": props.color ? "flat" : "tonal",
        "baseVariant": "text"
      }, events), {
        default: () => [base.dayFormatter.value(day, false)]
      });
    }
    function genBody() {
      return createBaseVNode("div", {
        "class": "v-calendar-daily__body"
      }, [genScrollArea()]);
    }
    function genScrollArea() {
      return createBaseVNode("div", {
        "ref": scrollArea,
        "class": "v-calendar-daily__scroll-area"
      }, [genPane()]);
    }
    function genPane() {
      return createBaseVNode("div", {
        "ref": pane,
        "class": "v-calendar-daily__pane",
        "style": {
          height: convertToUnit(base.bodyHeight.value)
        }
      }, [genDayContainer()]);
    }
    function genDayContainer() {
      return createBaseVNode("div", {
        "class": "v-calendar-daily__day-container"
      }, [genBodyIntervals(), slots.days?.() ?? genDays()]);
    }
    function genDays() {
      return base.days.value.map((day, index) => {
        const events = getPrefixedEventHandlers(attrs, ":time", (nativeEvent) => ({
          nativeEvent,
          ...base.getSlotScope(base.getTimestampAtEvent(nativeEvent, day))
        }));
        return createBaseVNode("div", mergeProps({
          "key": day.date,
          "class": ["v-calendar-daily__day", base.getRelativeClasses(day)]
        }, events), [genDayIntervals(index), genDayBody(day)]);
      });
    }
    function genDayBody(day) {
      return slots["day-body"]?.(base.getSlotScope(day)) ?? [];
    }
    function genDayIntervals(index) {
      return base.intervals.value[index].map(genDayInterval);
    }
    function genDayInterval(interval) {
      const height = convertToUnit(props.intervalHeight);
      const styler = props.intervalStyle || base.intervalStyleDefault;
      return createBaseVNode("div", {
        "class": "v-calendar-daily__day-interval",
        "key": interval.time,
        "style": normalizeStyle([{
          height
        }, styler(interval)])
      }, [slots.interval?.(base.getSlotScope(interval))]);
    }
    function genBodyIntervals() {
      const width = convertToUnit(props.intervalWidth);
      const events = getPrefixedEventHandlers(attrs, ":interval", (nativeEvent) => ({
        nativeEvent,
        ...base.getTimestampAtEvent(nativeEvent, base.parsedStart.value)
      }));
      return createBaseVNode("div", mergeProps({
        "class": "v-calendar-daily__intervals-body",
        "style": {
          width
        }
      }, events), [genIntervalLabels()]);
    }
    function genIntervalLabels() {
      if (!base.intervals.value.length) return null;
      return base.intervals.value[0].map(genIntervalLabel);
    }
    function genIntervalLabel(interval) {
      const height = convertToUnit(props.intervalHeight);
      const short = props.shortIntervals;
      const shower = props.showIntervalLabel || base.showIntervalLabelDefault;
      const show = shower(interval);
      const label = show ? base.intervalFormatter.value(interval, short) : void 0;
      return createBaseVNode("div", {
        "key": interval.time,
        "class": "v-calendar-daily__interval",
        "style": {
          height
        }
      }, [createBaseVNode("div", {
        "class": "v-calendar-daily__interval-text"
      }, [label])]);
    }
    onMounted(init);
    useRender(() => withDirectives(createBaseVNode("div", {
      "class": normalizeClass(["v-calendar-daily", attrs.class]),
      "onDragstart": (e) => e.preventDefault()
    }, [!props.hideHeader ? genHead() : void 0, genBody()]), [[resize_default, onResize, void 0, {
      quiet: true
    }]]));
    return {
      ...base,
      scrollPush,
      scrollArea,
      pane,
      init,
      onResize,
      getScrollPush
    };
  }
});

// node_modules/vuetify/lib/labs/VCalendar/util/parser.js
function parsedCategoryText(category, categoryText) {
  return typeof categoryText === "function" ? categoryText(category) : typeof categoryText === "string" && typeof category === "object" && category ? category[categoryText] : typeof category === "string" ? category : "";
}
function getParsedCategories(categories, categoryText) {
  if (typeof categories === "string") return categories.split(/\s*,\s/);
  if (Array.isArray(categories)) {
    return categories.map((category) => {
      if (typeof category === "string") return category;
      const categoryName = typeof category.categoryName === "string" ? category.categoryName : parsedCategoryText(category, categoryText);
      return {
        ...category,
        categoryName
      };
    });
  }
  return [];
}

// node_modules/vuetify/lib/labs/VCalendar/VCalendarCategory.js
var VCalendarCategory = defineComponent({
  name: "VCalendarCategory",
  props: {
    categories: {
      type: [Array, String],
      default: ""
    },
    categoryText: [String, Function],
    categoryForInvalid: {
      type: String,
      default: ""
    },
    ...makeCalendarBaseProps(),
    ...makeCalendarWithIntervalsProps()
  },
  setup(props, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    const base = useCalendarWithIntervals(props);
    const parsedCategories = computed(() => {
      return getParsedCategories(props.categories, props.categoryText);
    });
    function getCategoryScope(scope, category) {
      const cat = typeof category === "object" && category && category.categoryName === props.categoryForInvalid ? null : category;
      return {
        ...scope,
        category: cat
      };
    }
    function genDayHeader(scope) {
      return createBaseVNode("div", {
        "class": "v-calendar-category__columns"
      }, [parsedCategories.value.map((category) => {
        return genDayHeaderCategory(scope, getCategoryScope(scope, category));
      })]);
    }
    function genDayHeaderCategory(day, scope) {
      const headerTitle = typeof scope.category === "object" ? scope.category.categoryName : scope.category;
      const events = getPrefixedEventHandlers(attrs, ":dayCategory", () => {
        return getCategoryScope(base.getSlotScope(day) || day, scope.category);
      });
      return createBaseVNode("div", mergeProps({
        "class": "v-calendar-category__column-header"
      }, events), [slots.category?.(scope) ?? genDayHeaderCategoryTitle(headerTitle), slots["day-header"]?.(scope)]);
    }
    function genDayHeaderCategoryTitle(categoryName) {
      return createBaseVNode("div", {
        "class": "v-calendar-category__category"
      }, [categoryName === null ? props.categoryForInvalid : categoryName]);
    }
    function genDays() {
      const days = [];
      base.days.value.forEach((d, j) => {
        const day = new Array(parsedCategories.value.length || 1);
        day.fill(d);
        days.push(...day.map((v, i) => genDay(v, j, i)));
      });
      return days;
    }
    function genDay(day, index, categoryIndex) {
      const category = parsedCategories.value[categoryIndex];
      const events = getPrefixedEventHandlers(attrs, ":time", (e) => {
        return base.getSlotScope(base.getTimestampAtEvent(e, day));
      });
      return createBaseVNode("div", mergeProps({
        "key": day.date + "-" + categoryIndex,
        "class": ["v-calendar-daily__day", base.getRelativeClasses(day)]
      }, events), [genDayIntervals(index, category), genDayBody(day, category)]);
    }
    function genDayIntervals(index, category) {
      return base.intervals.value[index].map((v) => genDayInterval(v, category));
    }
    function genDayInterval(interval, category) {
      const height = convertToUnit(props.intervalHeight);
      const styler = props.intervalStyle || base.intervalStyleDefault;
      return createBaseVNode("div", {
        "key": interval.time,
        "class": "v-calendar-daily__day-interval",
        "style": normalizeStyle([{
          height
        }, styler({
          ...interval,
          category
        })])
      }, [slots.interval?.(getCategoryScope(base.getSlotScope(interval), category))]);
    }
    function genDayBody(day, category) {
      return createBaseVNode("div", {
        "class": "v-calendar-category__columns"
      }, [genDayBodyCategory(day, category)]);
    }
    function genDayBodyCategory(day, category) {
      const events = getPrefixedEventHandlers(attrs, ":timeCategory", (e) => {
        return getCategoryScope(base.getSlotScope(base.getTimestampAtEvent(e, day)), category);
      });
      return createBaseVNode("div", mergeProps({
        "class": "v-calendar-category__column"
      }, events), [slots["day-body"]?.(getCategoryScope(base.getSlotScope(day), category))]);
    }
    useRender(() => createVNode(VCalendarDaily, mergeProps({
      "class": ["v-calendar-daily", "v-calendar-category"]
    }, props), {
      ...slots,
      days: genDays,
      "day-header": genDayHeader
    }));
    return {
      ...base,
      parsedCategories
    };
  }
});

// node_modules/vuetify/lib/labs/VCalendar/VCalendarWeekly.js
var VCalendarWeekly = defineComponent({
  name: "VCalendarWeekly",
  props: {
    minWeeks: {
      validate: validateNumber,
      default: 1
    },
    monthFormat: Function,
    showWeek: Boolean,
    color: String,
    shortWeekdays: {
      type: Boolean,
      default: true
    },
    localeFirstDayOfYear: {
      type: [String, Number],
      default: 0
    },
    showMonthOnFirst: {
      type: Boolean,
      default: true
    },
    shortMonths: {
      type: Boolean,
      default: true
    },
    hideHeader: Boolean,
    ...makeCalendarBaseProps()
  },
  setup(props, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    const base = useCalendarBase(props);
    const theme = useTheme();
    const parsedMinWeeks = computed(() => {
      return parseInt(String(props.minWeeks));
    });
    const days = computed(() => {
      const minDays = parsedMinWeeks.value * base.parsedWeekdays.value.length;
      const start = base.getStartOfWeek(base.parsedStart.value);
      const end = base.getEndOfWeek(base.parsedEnd.value);
      return createDayList(start, end, base.times.today, base.weekdaySkips.value, Number.MAX_SAFE_INTEGER, minDays);
    });
    const todayWeek = computed(() => {
      const today = base.times.today;
      const start = base.getStartOfWeek(today);
      const end = base.getEndOfWeek(today);
      return createDayList(start, end, today, base.weekdaySkips.value, base.parsedWeekdays.value.length, base.parsedWeekdays.value.length);
    });
    const monthFormatter = computed(() => {
      if (props.monthFormat) {
        return props.monthFormat;
      }
      return createNativeLocaleFormatter(base.locale.current.value, (_tms, short) => ({
        timeZone: "UTC",
        month: short ? "short" : "long"
      }));
    });
    function isOutside(day) {
      const dayIdentifier = getDayIdentifier(day);
      return dayIdentifier < getDayIdentifier(base.parsedStart.value) || dayIdentifier > getDayIdentifier(base.parsedEnd.value);
    }
    function genHead() {
      return createBaseVNode("div", {
        "class": "v-calendar-weekly__head",
        "role": "row"
      }, [genHeadDays()]);
    }
    function genHeadDays() {
      const header = todayWeek.value.map(genHeadDay);
      if (props.showWeek) {
        header.unshift(createBaseVNode("div", {
          "class": "v-calendar-weekly__head-weeknumber"
        }, null));
      }
      return header;
    }
    function genHeadDay(day, index) {
      const outside = isOutside(days.value[index]);
      const color = day.present ? props.color : void 0;
      return createBaseVNode("div", mergeProps(base.getColorProps({
        text: color
      }), {
        "key": day.date,
        "class": ["v-calendar-weekly__head-weekday", base.getRelativeClasses(day, outside)],
        "role": "columnheader"
      }), [base.weekdayFormatter.value(day, props.shortWeekdays)]);
    }
    function genWeeks() {
      const daysValue = days.value;
      const weekDays = base.parsedWeekdays.value.length;
      const weeks = [];
      for (let i = 0; i < daysValue.length; i += weekDays) {
        weeks.push(genWeek(daysValue.slice(i, i + weekDays), getWeekNumber(daysValue[i])));
      }
      return weeks;
    }
    function genWeek(week, weekNumber2) {
      const weekNodes = week.map((day, index) => genDay(day, index, week));
      if (props.showWeek) {
        weekNodes.unshift(genWeekNumber(weekNumber2));
      }
      return createBaseVNode("div", {
        "key": week[0].date,
        "class": "v-calendar-weekly__week",
        "role": "row"
      }, [weekNodes]);
    }
    function getWeekNumber(determineDay) {
      return weekNumber(determineDay.year, determineDay.month - 1, determineDay.day, base.parsedWeekdays.value[0], parseInt(String(props.localeFirstDayOfYear)));
    }
    function genWeekNumber(weekNumber2) {
      return createBaseVNode("div", {
        "class": "v-calendar-weekly__weeknumber"
      }, [createBaseVNode("small", null, [String(weekNumber2)])]);
    }
    function genDay(day, index, week) {
      const outside = isOutside(day);
      const events = getPrefixedEventHandlers(attrs, ":day", (nativeEvent) => {
        return {
          nativeEvent,
          ...day
        };
      });
      return createBaseVNode("div", mergeProps({
        "key": day.date,
        "class": ["v-calendar-weekly__day", base.getRelativeClasses(day, outside)],
        "role": "cell"
      }, events), [genDayLabel(day), slots.day?.({
        outside,
        index,
        week,
        ...day
      })]);
    }
    function genDayLabel(day) {
      return createBaseVNode("div", {
        "class": "v-calendar-weekly__day-label"
      }, [slots["day-label"]?.(day) ?? genDayLabelButton(day)]);
    }
    function genDayLabelButton(day) {
      const hasMonth = day.day === 1 && props.showMonthOnFirst;
      const events = getPrefixedEventHandlers(attrs, ":date", (nativeEvent) => ({
        nativeEvent,
        ...day
      }));
      return createVNode(VIconBtn, mergeProps({
        "active": day.present,
        "activeColor": props.color,
        "variant": props.color ? "flat" : "tonal",
        "baseVariant": "text"
      }, events), {
        default: () => [hasMonth ? monthFormatter.value(day, props.shortMonths) + " " + base.dayFormatter.value(day, false) : base.dayFormatter.value(day, false)]
      });
    }
    useRender(() => createBaseVNode("div", {
      "class": normalizeClass(["v-calendar-weekly", theme.themeClasses.value]),
      "onDragstart": (e) => e.preventDefault()
    }, [!props.hideHeader ? genHead() : void 0, genWeeks()]));
    return {
      ...base,
      days,
      todayWeek,
      monthFormatter,
      isOutside
    };
  }
});

// node_modules/vuetify/lib/labs/VCalendar/composables/calendarWithEvents.js
import "C:/Users/islam/source/HRMS/client/node_modules/vuetify/lib/labs/VCalendar/composables/calendarWithEvents.css";

// node_modules/vuetify/lib/labs/VCalendar/modes/common.js
var MILLIS_IN_DAY = 864e5;
function getVisuals(events) {
  let minStart = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  const visuals = events.map((event) => ({
    event,
    columnCount: 0,
    column: 0,
    left: 0,
    width: 100
  }));
  visuals.sort((a, b) => {
    return Math.max(minStart, a.event.startTimestampIdentifier) - Math.max(minStart, b.event.startTimestampIdentifier) || b.event.endTimestampIdentifier - a.event.endTimestampIdentifier;
  });
  return visuals;
}
function hasOverlap(s0, e0, s1, e1) {
  let exclude = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
  return exclude ? !(s0 >= e1 || e0 <= s1) : !(s0 > e1 || e0 < s1);
}
function setColumnCount(groups) {
  groups.forEach((group) => {
    group.visuals.forEach((groupVisual) => {
      groupVisual.columnCount = groups.length;
    });
  });
}
function getRange(event) {
  return [event.startTimestampIdentifier, event.endTimestampIdentifier];
}
function getDayRange(event) {
  return [event.startIdentifier, event.endIdentifier];
}
function getNormalizedRange(event, dayStart) {
  return [Math.max(dayStart, event.startTimestampIdentifier), Math.min(dayStart + MILLIS_IN_DAY, event.endTimestampIdentifier)];
}
function getOpenGroup(groups, start, end, timed) {
  for (let i = 0; i < groups.length; i++) {
    const group = groups[i];
    let intersected = false;
    if (hasOverlap(start, end, group.start, group.end, timed)) {
      for (let k = 0; k < group.visuals.length; k++) {
        const groupVisual = group.visuals[k];
        const [groupStart, groupEnd] = timed ? getRange(groupVisual.event) : getDayRange(groupVisual.event);
        if (hasOverlap(start, end, groupStart, groupEnd, timed)) {
          intersected = true;
          break;
        }
      }
    }
    if (!intersected) {
      return i;
    }
  }
  return -1;
}
function getOverlapGroupHandler(firstWeekday) {
  const handler = {
    groups: [],
    min: -1,
    max: -1,
    reset: () => {
      handler.groups = [];
      handler.min = handler.max = -1;
    },
    getVisuals: function(day, dayEvents, timed) {
      let reset = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
      if (day.weekday === firstWeekday || reset) {
        handler.reset();
      }
      const dayStart = getTimestampIdentifier(day);
      const visuals = getVisuals(dayEvents, dayStart);
      visuals.forEach((visual) => {
        const [start, end] = timed ? getRange(visual.event) : getDayRange(visual.event);
        if (handler.groups.length > 0 && !hasOverlap(start, end, handler.min, handler.max, timed)) {
          setColumnCount(handler.groups);
          handler.reset();
        }
        let targetGroup = getOpenGroup(handler.groups, start, end, timed);
        if (targetGroup === -1) {
          targetGroup = handler.groups.length;
          handler.groups.push({
            start,
            end,
            visuals: []
          });
        }
        const target = handler.groups[targetGroup];
        target.visuals.push(visual);
        target.start = Math.min(target.start, start);
        target.end = Math.max(target.end, end);
        visual.column = targetGroup;
        if (handler.min === -1) {
          handler.min = start;
          handler.max = end;
        } else {
          handler.min = Math.min(handler.min, start);
          handler.max = Math.max(handler.max, end);
        }
      });
      setColumnCount(handler.groups);
      if (timed) {
        handler.reset();
      }
      return visuals;
    }
  };
  return handler;
}

// node_modules/vuetify/lib/labs/VCalendar/modes/column.js
var FULL_WIDTH = 100;
var column = (events, firstWeekday, overlapThreshold) => {
  const handler = getOverlapGroupHandler(firstWeekday);
  return (day, dayEvents, timed, reset) => {
    const visuals = handler.getVisuals(day, dayEvents, timed, reset);
    if (timed) {
      visuals.forEach((visual) => {
        visual.left = visual.column * FULL_WIDTH / visual.columnCount;
        visual.width = FULL_WIDTH / visual.columnCount;
      });
    }
    return visuals;
  };
};

// node_modules/vuetify/lib/labs/VCalendar/modes/stack.js
var FULL_WIDTH2 = 100;
var DEFAULT_OFFSET = 5;
var WIDTH_MULTIPLIER = 1.7;
var stack = (events, firstWeekday, overlapThreshold) => {
  const handler = getOverlapGroupHandler(firstWeekday);
  return (day, dayEvents, timed, reset) => {
    if (!timed) {
      return handler.getVisuals(day, dayEvents, timed, reset);
    }
    const dayStart = getTimestampIdentifier(day);
    const visuals = getVisuals(dayEvents, dayStart);
    const groups = getGroups(visuals, dayStart);
    for (const group of groups) {
      const nodes = [];
      for (const visual of group.visuals) {
        const child = getNode(visual, dayStart);
        const index = getNextIndex(child, nodes);
        if (index === false) {
          const parent = getParent(child, nodes);
          if (parent) {
            child.parent = parent;
            child.sibling = hasOverlap(child.start, child.end, parent.start, addTime(parent.start, overlapThreshold));
            child.index = parent.index + 1;
            parent.children.push(child);
          }
        } else {
          const [parent] = getOverlappingRange(child, nodes, index - 1, index - 1);
          const children = getOverlappingRange(child, nodes, index + 1, index + nodes.length, true);
          child.children = children;
          child.index = index;
          if (parent) {
            child.parent = parent;
            child.sibling = hasOverlap(child.start, child.end, parent.start, addTime(parent.start, overlapThreshold));
            parent.children.push(child);
          }
          for (const grand of children) {
            if (grand.parent === parent) {
              grand.parent = child;
            }
            const grandNext = grand.index - child.index <= 1;
            if (grandNext && child.sibling && hasOverlap(child.start, addTime(child.start, overlapThreshold), grand.start, grand.end)) {
              grand.sibling = true;
            }
          }
        }
        nodes.push(child);
      }
      calculateBounds(nodes, overlapThreshold);
    }
    visuals.sort((a, b) => a.left - b.left || a.event.startTimestampIdentifier - b.event.startTimestampIdentifier);
    return visuals;
  };
};
function calculateBounds(nodes, overlapThreshold) {
  for (const node of nodes) {
    const {
      visual,
      parent
    } = node;
    const columns = getMaxChildIndex(node) + 1;
    const spaceLeft = parent ? parent.visual.left : 0;
    const spaceWidth = FULL_WIDTH2 - spaceLeft;
    const offset = Math.min(DEFAULT_OFFSET, FULL_WIDTH2 / columns);
    const columnWidthMultiplier = getColumnWidthMultiplier(node, nodes);
    const columnOffset = spaceWidth / (columns - node.index + 1);
    const columnWidth = spaceWidth / (columns - node.index + (node.sibling ? 1 : 0)) * columnWidthMultiplier;
    if (parent) {
      visual.left = node.sibling ? spaceLeft + columnOffset : spaceLeft + offset;
    }
    visual.width = hasFullWidth(node, nodes, overlapThreshold) ? FULL_WIDTH2 - visual.left : Math.min(FULL_WIDTH2 - visual.left, columnWidth * WIDTH_MULTIPLIER);
  }
}
function getColumnWidthMultiplier(node, nodes) {
  if (!node.children.length) {
    return 1;
  }
  const maxColumn = node.index + nodes.length;
  const minColumn = node.children.reduce((min, c) => Math.min(min, c.index), maxColumn);
  return minColumn - node.index;
}
function getOverlappingIndices(node, nodes) {
  const indices = [];
  for (const other of nodes) {
    if (hasOverlap(node.start, node.end, other.start, other.end)) {
      indices.push(other.index);
    }
  }
  return indices;
}
function getNextIndex(node, nodes) {
  const indices = getOverlappingIndices(node, nodes);
  indices.sort();
  for (let i = 0; i < indices.length; i++) {
    if (i < indices[i]) {
      return i;
    }
  }
  return false;
}
function getOverlappingRange(node, nodes, indexMin, indexMax) {
  let returnFirstColumn = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
  const overlapping = [];
  for (const other of nodes) {
    if (other.index >= indexMin && other.index <= indexMax && hasOverlap(node.start, node.end, other.start, other.end)) {
      overlapping.push(other);
    }
  }
  if (returnFirstColumn && overlapping.length > 0) {
    const first = overlapping.reduce((min, n) => Math.min(min, n.index), overlapping[0].index);
    return overlapping.filter((n) => n.index === first);
  }
  return overlapping;
}
function getParent(node, nodes) {
  let parent = null;
  for (const other of nodes) {
    if (hasOverlap(node.start, node.end, other.start, other.end) && (parent === null || other.index > parent.index)) {
      parent = other;
    }
  }
  return parent;
}
function hasFullWidth(node, nodes, overlapThreshold) {
  for (const other of nodes) {
    if (other !== node && other.index > node.index && hasOverlap(node.start, addTime(node.start, overlapThreshold), other.start, other.end)) {
      return false;
    }
  }
  return true;
}
function getGroups(visuals, dayStart) {
  const groups = [];
  for (const visual of visuals) {
    const [start, end] = getNormalizedRange(visual.event, dayStart);
    let added = false;
    for (const group of groups) {
      if (hasOverlap(start, end, group.start, group.end)) {
        group.visuals.push(visual);
        group.end = Math.max(group.end, end);
        added = true;
        break;
      }
    }
    if (!added) {
      groups.push({
        start,
        end,
        visuals: [visual]
      });
    }
  }
  return groups;
}
function getNode(visual, dayStart) {
  const [start, end] = getNormalizedRange(visual.event, dayStart);
  return {
    parent: null,
    sibling: true,
    index: 0,
    visual,
    start,
    end,
    children: []
  };
}
function getMaxChildIndex(node) {
  let max = node.index;
  for (const child of node.children) {
    const childMax = getMaxChildIndex(child);
    if (childMax > max) {
      max = childMax;
    }
  }
  return max;
}
function addTime(identifier, minutes) {
  const removeMinutes = identifier % 100;
  const totalMinutes = removeMinutes + minutes;
  const addHours = Math.floor(totalMinutes / 60);
  const addMinutes = totalMinutes % 60;
  return identifier - removeMinutes + addHours * 100 + addMinutes;
}

// node_modules/vuetify/lib/labs/VCalendar/modes/index.js
var CalendarEventOverlapModes = {
  stack,
  column
};

// node_modules/vuetify/lib/labs/VCalendar/util/events.js
function parseEvent(input, index, startProperty, endProperty) {
  let timed = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
  let category = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : false;
  const startInput = input[startProperty];
  const endInput = input[endProperty];
  const startParsed = parseTimestamp(startInput, true);
  const endParsed = endInput ? parseTimestamp(endInput, true) : startParsed;
  const start = isTimedless(startInput) ? updateHasTime(startParsed, timed) : startParsed;
  const end = isTimedless(endInput) ? updateHasTime(endParsed, timed) : endParsed;
  const startIdentifier = getDayIdentifier(start);
  const startTimestampIdentifier = getTimestampIdentifier(start);
  const endIdentifier = getDayIdentifier(end);
  const endOffset = start.hasTime ? 0 : 2359;
  const endTimestampIdentifier = getTimestampIdentifier(end) + endOffset;
  const allDay = !start.hasTime;
  return {
    input,
    start,
    startIdentifier,
    startTimestampIdentifier,
    end,
    endIdentifier,
    endTimestampIdentifier,
    allDay,
    index,
    category
  };
}
function isEventOn(event, dayIdentifier) {
  return dayIdentifier >= event.startIdentifier && dayIdentifier <= event.endIdentifier;
}
function isEventHiddenOn(event, day) {
  return event.end.time === "00:00" && event.end.date === day.date && event.start.date !== day.date;
}
function isEventStart(event, day, dayIdentifier, firstWeekday) {
  return dayIdentifier === event.startIdentifier || firstWeekday === day.weekday && isEventOn(event, dayIdentifier);
}
function isEventOverlapping(event, startIdentifier, endIdentifier) {
  return startIdentifier <= event.endIdentifier && endIdentifier >= event.startIdentifier;
}

// node_modules/vuetify/lib/labs/VCalendar/composables/calendarWithEvents.js
var WIDTH_FULL = 100;
var WIDTH_START = 95;
var MINUTES_IN_DAY2 = 1440;
var makeCalendarWithEventsProps = propsFactory({
  events: {
    type: Array,
    default: () => []
  },
  eventStart: {
    type: String,
    default: "start"
  },
  eventEnd: {
    type: String,
    default: "end"
  },
  eventTimed: {
    type: [String, Function],
    default: "timed"
  },
  eventCategory: {
    type: [String, Function],
    default: "category"
  },
  eventHeight: {
    type: Number,
    default: 20
  },
  eventColor: {
    type: [String, Function],
    default: "primary"
  },
  eventTextColor: {
    type: [String, Function]
  },
  eventName: {
    type: [String, Function],
    default: "name"
  },
  eventOverlapThreshold: {
    type: [String, Number],
    default: 60
  },
  eventOverlapMode: {
    type: [String, Function],
    default: "stack",
    validate: (mode) => mode in CalendarEventOverlapModes || typeof mode === "function"
  },
  eventMore: {
    type: Boolean,
    default: true
  },
  eventMoreText: {
    type: String,
    default: "$vuetify.calendar.moreEvents"
  },
  eventRipple: {
    type: [Boolean, Object],
    default: null
  },
  eventMarginBottom: {
    type: Number,
    default: 1
  }
}, "VCalendar-events");
function useCalendarWithEvents(props, slots, attrs) {
  const base = useCalendarBase(props);
  const noEvents = computed(() => {
    return !Array.isArray(props.events) || props.events.length === 0;
  });
  const categoryMode = computed(() => {
    return props.type === "category";
  });
  const eventTimedFunction = computed(() => {
    return typeof props.eventTimed === "function" ? props.eventTimed : (event) => !!event[props.eventTimed];
  });
  const eventCategoryFunction = computed(() => {
    return typeof props.eventCategory === "function" ? props.eventCategory : (event) => event[props.eventCategory];
  });
  const parsedEvents = computed(() => {
    if (!props.events) return [];
    return props.events.map((event, index) => parseEvent(event, index, props.eventStart || "", props.eventEnd || "", eventTimedFunction.value(event), categoryMode.value ? eventCategoryFunction.value(event) : false));
  });
  const parsedEventOverlapThreshold = computed(() => {
    return parseInt(String(props.eventOverlapThreshold || 0));
  });
  const eventTextColorFunction = computed(() => {
    return typeof props.eventTextColor === "function" ? props.eventTextColor : () => props.eventTextColor;
  });
  const eventNameFunction = computed(() => {
    return typeof props.eventName === "function" ? props.eventName : (event, timedEvent) => event.input[props.eventName] || "";
  });
  const eventModeFunction = computed(() => {
    return typeof props.eventOverlapMode === "function" ? props.eventOverlapMode : CalendarEventOverlapModes[props.eventOverlapMode];
  });
  const eventWeekdays = computed(() => {
    return base.effectiveWeekdays.value;
  });
  function eventColorFunction(e) {
    return typeof props.eventColor === "function" ? props.eventColor(e) : e.color || props.eventColor;
  }
  const eventsRef = ref([]);
  function updateEventVisibility() {
    if (noEvents.value || !props.eventMore) {
      return;
    }
    const eventHeight = props.eventHeight || 0;
    const eventsMap = getEventsMap();
    for (const date in eventsMap) {
      const {
        parent,
        events,
        more
      } = eventsMap[date];
      if (!more) {
        break;
      }
      const parentBounds = parent.getBoundingClientRect();
      const last = events.length - 1;
      const eventsSorted = events.map((event) => ({
        event,
        bottom: event.getBoundingClientRect().bottom
      })).sort((a, b) => a.bottom - b.bottom);
      let hidden = 0;
      for (let i = 0; i <= last; i++) {
        const bottom = eventsSorted[i].bottom;
        const hide = i === last ? bottom > parentBounds.bottom : bottom + eventHeight > parentBounds.bottom;
        if (hide) {
          eventsSorted[i].event.style.display = "none";
          hidden++;
        }
      }
      if (hidden) {
        more.style.display = "";
        more.innerHTML = base.locale.t(props.eventMoreText, hidden);
      } else {
        more.style.display = "none";
      }
    }
  }
  function getEventsMap() {
    const eventsMap = {};
    const elements = eventsRef.value;
    if (!elements || !elements.length) {
      return eventsMap;
    }
    elements.forEach((el) => {
      const date = el.getAttribute("data-date");
      if (el.parentElement && date) {
        if (!(date in eventsMap)) {
          eventsMap[date] = {
            parent: el.parentElement,
            more: null,
            events: []
          };
        }
        if (el.getAttribute("data-more")) {
          eventsMap[date].more = el;
        } else {
          eventsMap[date].events.push(el);
          el.style.display = "";
        }
      }
    });
    return eventsMap;
  }
  function genDayEvent(_ref, day) {
    let {
      event
    } = _ref;
    const eventHeight = props.eventHeight || 0;
    const eventMarginBottom = props.eventMarginBottom || 0;
    const dayIdentifier = getDayIdentifier(day);
    const week = day.week;
    const start = dayIdentifier === event.startIdentifier;
    let end = dayIdentifier === event.endIdentifier;
    let width = WIDTH_START;
    if (!categoryMode.value) {
      for (let i = day.index + 1; i < week.length; i++) {
        const weekdayIdentifier = getDayIdentifier(week[i]);
        if (event.endIdentifier >= weekdayIdentifier) {
          width += WIDTH_FULL;
          end = end || weekdayIdentifier === event.endIdentifier;
        } else {
          end = true;
          break;
        }
      }
    }
    const scope = {
      eventParsed: event,
      day,
      start,
      end,
      timed: false
    };
    return genEvent(event, scope, false, {
      class: ["v-event", {
        "v-event-start": start,
        "v-event-end": end
      }],
      style: {
        height: `${eventHeight}px`,
        width: `${width}%`,
        marginBottom: `${eventMarginBottom}px`
      },
      "data-date": day.date
    });
  }
  function genTimedEvent(_ref2, day) {
    let {
      event,
      left,
      width
    } = _ref2;
    const endDelta = day.timeDelta(event.end);
    const startDelta = day.timeDelta(event.start);
    if (endDelta === false || startDelta === false || endDelta < 0 || startDelta >= 1 || isEventHiddenOn(event, day)) {
      return false;
    }
    const dayIdentifier = getDayIdentifier(day);
    const start = event.startIdentifier >= dayIdentifier;
    const end = event.endIdentifier > dayIdentifier;
    const top = start ? day.timeToY(event.start) : 0;
    const bottom = end ? day.timeToY(MINUTES_IN_DAY2) : day.timeToY(event.end);
    const height = Math.max(props.eventHeight || 0, bottom - top);
    const scope = {
      eventParsed: event,
      day,
      start,
      end,
      timed: true
    };
    return genEvent(event, scope, true, {
      class: "v-event-timed",
      style: {
        top: `${top}px`,
        height: `${height}px`,
        left: `${left}%`,
        width: `${width}%`
      }
    });
  }
  function genEvent(event, scopeInput, timedEvent, data) {
    const slot = slots.event;
    const text = eventTextColorFunction.value(event.input);
    const background = eventColorFunction(event.input);
    const overlapsNoon = event.start.hour < 12 && event.end.hour >= 12;
    const singline = diffMinutes(event.start, event.end) <= parsedEventOverlapThreshold.value;
    const formatTime2 = (withTime, ampm) => {
      const formatter = base.getFormatter({
        timeZone: "UTC",
        hour: "numeric",
        minute: withTime.minute > 0 ? "numeric" : void 0
      });
      return formatter(withTime, true);
    };
    const timeSummary = () => formatTime2(event.start, overlapsNoon) + " - " + formatTime2(event.end, true);
    const eventSummary = () => {
      const name = eventNameFunction.value(event, timedEvent);
      if (event.start.hasTime) {
        if (timedEvent) {
          const time = timeSummary();
          const delimiter = singline ? ", " : createBaseVNode("br", null, null);
          return createBaseVNode("span", {
            "class": "v-event-summary"
          }, [createBaseVNode("strong", null, [name]), delimiter, time]);
        } else {
          const time = formatTime2(event.start, true);
          return createBaseVNode("span", {
            "class": "v-event-summary"
          }, [createBaseVNode("strong", null, [time]), createTextVNode(" "), name]);
        }
      }
      return createBaseVNode("span", {
        "class": "v-event-summary"
      }, [name]);
    };
    const scope = {
      ...scopeInput,
      event: event.input,
      outside: scopeInput.day.outside,
      singline,
      overlapsNoon,
      formatTime: formatTime2,
      timeSummary,
      eventSummary
    };
    const events = getPrefixedEventHandlers(attrs, ":event", (nativeEvent) => ({
      ...scope,
      nativeEvent
    }));
    return withDirectives(createBaseVNode("div", mergeProps(base.getColorProps({
      text,
      background
    }), events, data, {
      "ref_for": true,
      "ref": eventsRef
    }), [slot?.(scope) ?? genName(eventSummary)]), [[ripple_default, props.eventRipple ?? true]]);
  }
  function genName(eventSummary) {
    return createBaseVNode("div", {
      "class": "pl-1"
    }, [eventSummary()]);
  }
  function genPlaceholder(day) {
    const height = (props.eventHeight || 0) + (props.eventMarginBottom || 0);
    return createBaseVNode("div", {
      "style": {
        height: `${height}px`
      },
      "data-date": day.date,
      "ref_for": true,
      "ref": eventsRef
    }, null);
  }
  function genMore(day) {
    const eventHeight = props.eventHeight || 0;
    const eventMarginBottom = props.eventMarginBottom || 0;
    const events = getPrefixedEventHandlers(attrs, ":more", (nativeEvent) => ({
      nativeEvent,
      ...day
    }));
    return withDirectives(createBaseVNode("div", mergeProps({
      "class": ["v-event-more pl-1", {
        "v-outside": day.outside
      }],
      "data-date": day.date,
      "data-more": "1",
      "style": {
        display: "none",
        height: `${eventHeight}px`,
        marginBottom: `${eventMarginBottom}px`
      },
      "ref_for": true,
      "ref": eventsRef
    }, events), null), [[ripple_default, props.eventRipple ?? true]]);
  }
  function getVisibleEvents() {
    const days = base.days.value;
    const start = getDayIdentifier(days[0]);
    const end = getDayIdentifier(days[days.length - 1]);
    return parsedEvents.value.filter((event) => isEventOverlapping(event, start, end));
  }
  function isEventForCategory(event, category) {
    return !categoryMode.value || typeof category === "object" && category.categoryName && category.categoryName === event.category || typeof event.category === "string" && category === event.category || typeof event.category !== "string" && category === null;
  }
  function getEventsForDay(day) {
    const identifier = getDayIdentifier(day);
    const firstWeekday = eventWeekdays.value[0];
    return parsedEvents.value.filter((event) => isEventStart(event, day, identifier, firstWeekday));
  }
  function getEventsForDayAll(day) {
    const identifier = getDayIdentifier(day);
    const firstWeekday = eventWeekdays.value[0];
    return parsedEvents.value.filter((event) => event.allDay && (categoryMode.value ? isEventOn(event, identifier) : isEventStart(event, day, identifier, firstWeekday)) && isEventForCategory(event, day.category));
  }
  function getEventsForDayTimed(day) {
    const identifier = getDayIdentifier(day);
    return parsedEvents.value.filter((event) => !event.allDay && isEventOn(event, identifier) && isEventForCategory(event, day.category));
  }
  function getScopedSlots() {
    if (noEvents.value) {
      return {
        ...slots
      };
    }
    const mode = eventModeFunction.value(parsedEvents.value, eventWeekdays.value[0], parsedEventOverlapThreshold.value);
    const isNode = (input) => !!input;
    const getSlotChildren = (day, getter, mapper, timed) => {
      const events = getter(day);
      const visuals = mode(day, events, timed, categoryMode.value);
      if (timed) {
        return visuals.map((visual) => mapper(visual, day)).filter(isNode);
      }
      const children = [];
      visuals.forEach((visual, index) => {
        while (children.length < visual.column) {
          children.push(genPlaceholder(day));
        }
        const mapped = mapper(visual, day);
        if (mapped) {
          children.push(mapped);
        }
      });
      return children;
    };
    return {
      ...slots,
      day: (day) => {
        let children = getSlotChildren(day, getEventsForDay, genDayEvent, false);
        if (children && children.length > 0 && props.eventMore) {
          children.push(genMore(day));
        }
        if (slots.day) {
          const slot = slots.day(day);
          if (slot) {
            children = children ? children.concat(slot) : slot;
          }
        }
        return children;
      },
      "day-header": (day) => {
        let children = getSlotChildren(day, getEventsForDayAll, genDayEvent, false);
        if (slots["day-header"]) {
          const slot = slots["day-header"](day);
          if (slot) {
            children = children ? children.concat(slot) : slot;
          }
        }
        return children;
      },
      "day-body": (day) => {
        const events = getSlotChildren(day, getEventsForDayTimed, genTimedEvent, true);
        let children = [createBaseVNode("div", {
          "class": "v-event-timed-container"
        }, [events])];
        if (slots["day-body"]) {
          const slot = slots["day-body"](day);
          if (slot) {
            children = children.concat(slot);
          }
        }
        return children;
      }
    };
  }
  return {
    ...base,
    noEvents,
    parsedEvents,
    parsedEventOverlapThreshold,
    eventTimedFunction,
    eventCategoryFunction,
    eventTextColorFunction,
    eventNameFunction,
    eventModeFunction,
    eventWeekdays,
    categoryMode,
    eventColorFunction,
    eventsRef,
    updateEventVisibility,
    getEventsMap,
    genDayEvent,
    genTimedEvent,
    genEvent,
    genName,
    genPlaceholder,
    genMore,
    getVisibleEvents,
    isEventForCategory,
    getEventsForDay,
    getEventsForDayAll,
    getEventsForDayTimed,
    getScopedSlots
  };
}

// node_modules/vuetify/lib/labs/VCalendar/VCalendar.js
var VCalendar = genericComponent()({
  name: "VCalendar",
  directives: {
    vResize: resize_default
  },
  props: {
    modelValue: {
      type: [String, Number, Date],
      validate: validateTimestamp
    },
    categoryDays: {
      type: [Number, String],
      default: 1,
      validate: (x) => isFinite(parseInt(x)) && parseInt(x) > 0
    },
    categories: {
      type: [Array, String],
      default: ""
    },
    categoryText: {
      type: [String, Function]
    },
    maxDays: {
      type: Number,
      default: 7
    },
    categoryHideDynamic: {
      type: Boolean
    },
    categoryShowAll: {
      type: Boolean
    },
    categoryForInvalid: {
      type: String,
      default: ""
    },
    ...makeCalendarBaseProps(),
    ...makeCalendarWithEventsProps()
  },
  setup(props, _ref) {
    let {
      slots,
      attrs,
      emit
    } = _ref;
    const root = ref();
    const base = useCalendarWithEvents(props, slots, attrs);
    const lastStart = ref(null);
    const lastEnd = ref(null);
    const parsedCategoryDays = computed(() => {
      return parseInt(String(props.categoryDays)) || 1;
    });
    const parsedCategories = computed(() => {
      return getParsedCategories(props.categories, props.categoryText);
    });
    const renderProps = computed(() => {
      const around = base.parsedValue.value;
      let component = null;
      let maxDays = props.maxDays;
      let categories = parsedCategories.value;
      let start = around;
      let end = around;
      switch (props.type) {
        case "month":
          component = VCalendarWeekly;
          start = getStartOfMonth(around);
          end = getEndOfMonth(around);
          break;
        case "week":
          component = VCalendarDaily;
          start = base.getStartOfWeek(around);
          end = base.getEndOfWeek(around);
          maxDays = 7;
          break;
        case "day":
          component = VCalendarDaily;
          maxDays = 1;
          break;
        case "4day":
          component = VCalendarDaily;
          end = relativeDays(copyTimestamp(end), nextDay, 3);
          updateFormatted(end);
          maxDays = 4;
          break;
        case "custom-weekly":
          component = VCalendarWeekly;
          start = base.parsedStart.value || around;
          end = base.parsedEnd.value;
          break;
        case "custom-daily":
          component = VCalendarDaily;
          start = base.parsedStart.value || around;
          end = base.parsedEnd.value;
          break;
        case "category":
          const days = parsedCategoryDays.value;
          component = VCalendarCategory;
          end = relativeDays(copyTimestamp(end), nextDay, days);
          updateFormatted(end);
          maxDays = days;
          categories = getCategoryList(categories);
          break;
        default:
          const type = props.type;
          throw new Error(`${type} is not a valid Calendar type`);
      }
      return {
        component,
        start,
        end,
        maxDays,
        categories
      };
    });
    const eventWeekdays = computed(() => {
      return base.effectiveWeekdays.value;
    });
    const categoryMode = computed(() => {
      return props.type === "category";
    });
    const monthLongFormatter = computed(() => {
      return base.getFormatter({
        timeZone: "UTC",
        month: "long"
      });
    });
    const monthShortFormatter = computed(() => {
      return base.getFormatter({
        timeZone: "UTC",
        month: "short"
      });
    });
    const title = computed(() => {
      const {
        start,
        end
      } = renderProps.value;
      const spanYears = start.year !== end.year;
      const spanMonths = spanYears || start.month !== end.month;
      if (spanYears) {
        return monthShortFormatter.value(start, true) + " " + start.year + " - " + monthShortFormatter.value(end, true) + " " + end.year;
      }
      if (spanMonths) {
        return monthShortFormatter.value(start, true) + " - " + monthShortFormatter.value(end, true) + " " + end.year;
      } else {
        return monthLongFormatter.value(start, false) + " " + start.year;
      }
    });
    function checkChange() {
      const {
        start,
        end
      } = renderProps.value;
      if (!lastStart.value || !lastEnd.value || start.date !== lastStart.value.date || end.date !== lastEnd.value.date) {
        lastStart.value = start;
        lastEnd.value = end;
        emit("change", {
          start,
          end
        });
      }
    }
    function move() {
      let amount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
      const moved = copyTimestamp(base.parsedValue.value);
      const forward = amount > 0;
      const mover = forward ? nextDay : prevDay;
      const limit = forward ? DAYS_IN_MONTH_MAX : DAY_MIN;
      let times = forward ? amount : -amount;
      while (--times >= 0) {
        switch (props.type) {
          case "month":
            moved.day = limit;
            mover(moved);
            break;
          case "week":
            relativeDays(moved, mover, DAYS_IN_WEEK);
            break;
          case "day":
            relativeDays(moved, mover, 1);
            break;
          case "4day":
            relativeDays(moved, mover, 4);
            break;
          case "category":
            relativeDays(moved, mover, parsedCategoryDays.value);
            break;
        }
      }
      updateWeekday(moved);
      updateFormatted(moved);
      updateRelative(moved, base.times.now);
      if (props.modelValue instanceof Date) {
        emit("update:modelValue", timestampToDate(moved));
      } else if (typeof props.modelValue === "number") {
        emit("update:modelValue", timestampToDate(moved).getTime());
      } else {
        emit("update:modelValue", moved.date);
      }
      emit("moved", moved);
    }
    function next() {
      let amount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
      move(amount);
    }
    function prev() {
      let amount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
      move(-amount);
    }
    function getCategoryList(categories) {
      if (!base.noEvents.value) {
        const categoryMap = categories.reduce((map, category, index) => {
          if (typeof category === "object" && category.categoryName) map[category.categoryName] = {
            index,
            count: 0
          };
          else if (typeof category === "string") map[category] = {
            index,
            count: 0
          };
          return map;
        }, {});
        if (!props.categoryHideDynamic || !props.categoryShowAll) {
          let categoryLength = categories.length;
          base.parsedEvents.value.forEach((ev) => {
            let category = ev.category;
            if (typeof category !== "string") {
              category = props.categoryForInvalid;
            }
            if (!category) {
              return;
            }
            if (category in categoryMap) {
              categoryMap[category].count++;
            } else if (!props.categoryHideDynamic) {
              categoryMap[category] = {
                index: categoryLength++,
                count: 1
              };
            }
          });
        }
        if (!props.categoryShowAll) {
          for (const category in categoryMap) {
            if (categoryMap[category].count === 0) {
              delete categoryMap[category];
            }
          }
        }
        categories = categories.filter((category) => {
          if (typeof category === "object" && category.categoryName) {
            return categoryMap.hasOwnProperty(category.categoryName);
          } else if (typeof category === "string") {
            return categoryMap.hasOwnProperty(category);
          }
          return false;
        });
      }
      return categories;
    }
    watch(renderProps, checkChange);
    onMounted(() => {
      base.updateEventVisibility();
      checkChange();
    });
    onUpdated(() => {
      window.requestAnimationFrame(base.updateEventVisibility);
    });
    useRender(() => {
      const {
        start,
        end,
        maxDays,
        component: Component,
        categories
      } = renderProps.value;
      return withDirectives(createVNode(Component, mergeProps({
        "ref": root,
        "class": ["v-calendar", {
          "v-calendar-events": !base.noEvents.value
        }],
        "role": "grid"
      }, Component.filterProps(props), {
        "start": start.date,
        "end": end.date,
        "maxDays": maxDays,
        "weekdays": base.effectiveWeekdays.value,
        "categories": categories,
        "onClick:date": (e, day) => {
          if (attrs["onUpdate:modelValue"]) emit("update:modelValue", day.date);
        }
      }), base.getScopedSlots()), [[resize_default, base.updateEventVisibility, void 0, {
        quiet: true
      }]]);
    });
    return forwardRefs({
      ...base,
      lastStart,
      lastEnd,
      parsedCategoryDays,
      renderProps,
      eventWeekdays,
      categoryMode,
      title,
      monthLongFormatter,
      monthShortFormatter,
      parsedCategories,
      checkChange,
      move,
      next,
      prev,
      getCategoryList
    }, root);
  }
});

// node_modules/vuetify/lib/labs/VColorInput/VColorInput.js
import "C:/Users/islam/source/HRMS/client/node_modules/vuetify/lib/labs/VColorInput/VColorInput.css";
var availablePipLocations = ["prepend", "prepend-inner", "append", "append-inner"];
var makeVColorInputProps = propsFactory({
  hidePip: Boolean,
  colorPip: Boolean,
  pipIcon: {
    type: String,
    default: "$color"
  },
  pipLocation: {
    type: String,
    default: "prepend",
    validator: (v) => availablePipLocations.includes(v)
  },
  pipVariant: {
    type: String,
    default: "text"
  },
  ...makeFocusProps(),
  ...makeVConfirmEditProps(),
  ...makeVTextFieldProps(),
  ...omit(makeVColorPickerProps(), ["width"])
}, "VColorInput");
var VColorInput = genericComponent()({
  name: "VColorInput",
  props: makeVColorInputProps(),
  emits: {
    "update:modelValue": (val) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const model = useProxiedModel(props, "modelValue");
    const menu = shallowRef(false);
    const isFocused = shallowRef(props.focused);
    const isInteractive = computed(() => !props.disabled && !props.readonly);
    const display = computed(() => model.value || null);
    function onKeydown(e) {
      if (e.key !== "Enter") return;
      if (!menu.value || !isFocused.value) {
        menu.value = true;
        return;
      }
      const target = e.target;
      model.value = target.value;
    }
    function onClick(e) {
      e.preventDefault();
      e.stopPropagation();
      menu.value = true;
    }
    function onSave() {
      menu.value = false;
    }
    function onCancel() {
      menu.value = false;
    }
    useRender(() => {
      const confirmEditProps = VConfirmEdit.filterProps(props);
      const colorPickerProps = VColorPicker.filterProps(omit(props, ["active", "color"]));
      const textFieldProps = VTextField.filterProps(props);
      const slotWithPip = props.hidePip ? void 0 : {
        [props.pipLocation]: (arg) => createBaseVNode(Fragment, null, [createVNode(VAvatar, {
          "class": "v-color-input__pip",
          "color": props.colorPip ? model.value : void 0,
          "variant": props.pipVariant,
          "icon": props.pipIcon
        }, null), slots[props.pipLocation]?.(arg)])
      };
      return createVNode(VTextField, mergeProps(textFieldProps, {
        "class": ["v-color-input", props.class],
        "style": props.style,
        "modelValue": display.value,
        "onKeydown": isInteractive.value ? onKeydown : void 0,
        "focused": menu.value || isFocused.value,
        "onClick:control": isInteractive.value ? onClick : void 0,
        "onClick:prependInner": isInteractive.value ? onClick : void 0,
        "onUpdate:focused": (event) => isFocused.value = event,
        "onClick:appendInner": isInteractive.value ? onClick : void 0,
        "onUpdate:modelValue": (val) => {
          model.value = val;
        }
      }), {
        ...slots,
        ...slotWithPip,
        default: () => createBaseVNode(Fragment, null, [createVNode(VMenu, {
          "modelValue": menu.value,
          "onUpdate:modelValue": ($event) => menu.value = $event,
          "activator": "parent",
          "minWidth": "0",
          "closeOnContentClick": false,
          "openOnClick": false
        }, {
          default: () => [createVNode(VConfirmEdit, mergeProps(confirmEditProps, {
            "modelValue": model.value,
            "onUpdate:modelValue": ($event) => model.value = $event,
            "onSave": onSave,
            "onCancel": onCancel
          }), {
            default: (_ref2) => {
              let {
                actions,
                model: proxyModel,
                save,
                cancel,
                isPristine
              } = _ref2;
              function onUpdateModel(value) {
                if (!props.hideActions) {
                  proxyModel.value = value;
                } else {
                  model.value = value;
                }
              }
              return createVNode(VColorPicker, mergeProps(colorPickerProps, {
                "modelValue": props.hideActions ? model.value : proxyModel.value,
                "onUpdate:modelValue": (value) => onUpdateModel(value)
              }), {
                actions: !props.hideActions ? () => slots.actions?.({
                  save,
                  cancel,
                  isPristine
                }) ?? actions() : void 0
              });
            }
          })]
        }), slots.default?.()])
      });
    });
  }
});

// node_modules/vuetify/lib/composables/dateFormat.js
var DateFormatSpec = class _DateFormatSpec {
  constructor(order, separator) {
    this.order = order;
    this.separator = separator;
  }
  get format() {
    return this.order.split("").map((sign) => `${sign}${sign}`).join(this.separator).replace("yy", "yyyy");
  }
  static canBeParsed(v) {
    if (typeof v !== "string") return false;
    const lowercase = v.toLowerCase();
    return ["y", "m", "d"].every((sign) => lowercase.includes(sign)) && ["/", "-", "."].some((sign) => v.includes(sign));
  }
  static parse(v) {
    if (!_DateFormatSpec.canBeParsed(v)) {
      throw new Error(`[${v}] cannot be parsed into date format specification`);
    }
    const order = v.toLowerCase().split("").filter((c, i, all) => "dmy".includes(c) && all.indexOf(c) === i).join("");
    const separator = ["/", "-", "."].find((sign) => v.includes(sign));
    return new _DateFormatSpec(order, separator);
  }
};
var makeDateFormatProps = propsFactory({
  inputFormat: {
    type: String,
    validator: (v) => !v || DateFormatSpec.canBeParsed(v)
  }
}, "date-format");
function useDateFormat(props, locale) {
  const adapter = useDate();
  function inferFromLocale() {
    const localeForDateFormat = locale.value ?? "en-US";
    const formatFromLocale = Intl.DateTimeFormat(localeForDateFormat, {
      year: "numeric",
      month: "2-digit",
      day: "2-digit"
    }).format(adapter.toJsDate(adapter.parseISO("1999-12-07"))).replace(/(07)|()|()|()|()/, "dd").replace(/(12)|()|()|()|()/, "mm").replace(/(1999)|(2542)|()|()|()|()/, "yyyy").replace(/[^ymd\-/.]/g, "").replace(/\.$/, "");
    if (!DateFormatSpec.canBeParsed(formatFromLocale)) {
      consoleWarn(`Date format inferred from locale [${localeForDateFormat}] is invalid: [${formatFromLocale}]`);
      return "mm/dd/yyyy";
    }
    return formatFromLocale;
  }
  const currentFormat = toRef(() => {
    return DateFormatSpec.canBeParsed(props.inputFormat) ? DateFormatSpec.parse(props.inputFormat) : DateFormatSpec.parse(inferFromLocale());
  });
  function parseDate2(dateString) {
    function parseDateParts(text) {
      const parts = text.trim().split(currentFormat.value.separator);
      return {
        y: Number(parts[currentFormat.value.order.indexOf("y")]),
        m: Number(parts[currentFormat.value.order.indexOf("m")]),
        d: Number(parts[currentFormat.value.order.indexOf("d")])
      };
    }
    function validateDateParts(dateParts2) {
      const {
        y: year2,
        m: month2,
        d: day2
      } = dateParts2;
      if (!year2 || !month2 || !day2) return null;
      if (month2 < 1 || month2 > 12) return null;
      if (day2 < 1 || day2 > 31) return null;
      return {
        year: autoFixYear(year2),
        month: month2,
        day: day2
      };
    }
    function autoFixYear(year2) {
      const currentYear = adapter.getYear(adapter.date());
      if (year2 > 100 || currentYear % 100 >= 50) {
        return year2;
      }
      const currentCentury = ~~(currentYear / 100) * 100;
      return year2 < 50 ? currentCentury + year2 : currentCentury - 100 + year2;
    }
    const dateParts = parseDateParts(dateString);
    const validatedParts = validateDateParts(dateParts);
    if (!validatedParts) return null;
    const {
      year,
      month,
      day
    } = validatedParts;
    const pad = (v) => String(v).padStart(2, "0");
    return adapter.parseISO(`${year}-${pad(month)}-${pad(day)}`);
  }
  function isValid(text) {
    return !!parseDate2(text);
  }
  function formatDate(value) {
    const parts = adapter.toISO(value).split("T")[0].split("-");
    return currentFormat.value.order.split("").map((sign) => parts["ymd".indexOf(sign)]).join(currentFormat.value.separator);
  }
  return {
    isValid,
    parseDate: parseDate2,
    formatDate,
    parserFormat: toRef(() => currentFormat.value.format)
  };
}

// node_modules/vuetify/lib/labs/VDateInput/VDateInput.js
var makeVDateInputProps = propsFactory({
  displayFormat: {
    type: [Function, String],
    default: void 0
  },
  location: {
    type: String,
    default: "bottom start"
  },
  menu: Boolean,
  updateOn: {
    type: Array,
    default: () => ["blur", "enter"]
  },
  ...makeDateFormatProps(),
  ...makeDisplayProps({
    mobile: null
  }),
  ...makeFocusProps(),
  ...makeVConfirmEditProps({
    hideActions: true
  }),
  ...makeVTextFieldProps({
    prependIcon: "$calendar"
  }),
  ...omit(makeVDatePickerProps({
    hideHeader: true,
    showAdjacentMonths: true
  }), ["active", "location", "rounded"])
}, "VDateInput");
var VDateInput = genericComponent()({
  name: "VDateInput",
  props: makeVDateInputProps(),
  emits: {
    save: (value) => true,
    cancel: () => true,
    "update:focused": (val) => true,
    "update:modelValue": (val) => true,
    "update:menu": (val) => true
  },
  setup(props, _ref) {
    let {
      emit,
      slots
    } = _ref;
    const {
      t,
      current: currentLocale
    } = useLocale();
    const adapter = useDate();
    const {
      isValid,
      parseDate: parseDate2,
      formatDate,
      parserFormat
    } = useDateFormat(props, currentLocale);
    const {
      mobile
    } = useDisplay(props);
    const emptyModelValue = () => props.multiple ? [] : null;
    const model = useProxiedModel(props, "modelValue", emptyModelValue(), (val) => Array.isArray(val) ? val.map((item) => adapter.toJsDate(item)) : val ? adapter.toJsDate(val) : val, (val) => Array.isArray(val) ? val.map((item) => adapter.date(item)) : val ? adapter.date(val) : val);
    const menu = useProxiedModel(props, "menu");
    const isEditingInput = shallowRef(false);
    const isFocused = shallowRef(props.focused);
    const vTextFieldRef = ref();
    const disabledActions = ref(["save"]);
    function format(date) {
      if (typeof props.displayFormat === "function") {
        return props.displayFormat(date);
      }
      if (props.displayFormat) {
        return adapter.format(date, props.displayFormat ?? "keyboardDate");
      }
      return formatDate(date);
    }
    const display = computed(() => {
      const value = wrapInArray(model.value);
      if (!value.length) return null;
      if (props.multiple === true) {
        return t("$vuetify.datePicker.itemsSelected", value.length);
      }
      if (props.multiple === "range") {
        const start = value[0];
        const end = value[value.length - 1];
        if (!adapter.isValid(start) || !adapter.isValid(end)) return "";
        return `${format(adapter.date(start))} - ${format(adapter.date(end))}`;
      }
      return adapter.isValid(model.value) ? format(adapter.date(model.value)) : "";
    });
    const inputmode = computed(() => {
      if (!mobile.value) return void 0;
      if (isEditingInput.value) return "text";
      return "none";
    });
    const isInteractive = computed(() => !props.disabled && !props.readonly);
    const isReadonly = computed(() => {
      if (!props.updateOn.length) return true;
      return !(mobile.value && isEditingInput.value) && props.readonly;
    });
    watch(menu, (val) => {
      if (val) return;
      isEditingInput.value = false;
      disabledActions.value = ["save"];
    });
    function onKeydown(e) {
      if (e.key !== "Enter") return;
      if (!menu.value || !isFocused.value) {
        menu.value = true;
      }
      if (props.updateOn.includes("enter")) {
        onUserInput(e.target);
      }
    }
    function onClick(e) {
      e.preventDefault();
      e.stopPropagation();
      if (menu.value && mobile.value) {
        isEditingInput.value = true;
      } else {
        menu.value = true;
      }
    }
    function onCancel() {
      emit("cancel");
      menu.value = false;
      isEditingInput.value = false;
    }
    function onSave(value) {
      emit("save", value);
      menu.value = false;
    }
    function onUpdateDisplayModel(value) {
      if (value != null) return;
      model.value = emptyModelValue();
    }
    function onBlur(e) {
      if (props.updateOn.includes("blur")) {
        onUserInput(e.target);
      }
      if (mobile.value && isEditingInput.value && !isFocused.value) {
        menu.value = false;
        isEditingInput.value = false;
      }
    }
    function onUserInput(_ref2) {
      let {
        value
      } = _ref2;
      if (!value.trim()) {
        model.value = emptyModelValue();
      } else if (!props.multiple) {
        if (isValid(value)) {
          model.value = parseDate2(value);
        }
      } else {
        const parts = value.trim().split(/\D+-\D+|[^\d\-/.]+/);
        if (parts.every(isValid)) {
          if (props.multiple === "range") {
            const [start, stop] = parts.map(parseDate2).toSorted((a, b) => adapter.isAfter(a, b) ? 1 : -1);
            model.value = createDateRange(adapter, start, stop);
          } else {
            model.value = parts.map(parseDate2);
          }
        }
      }
    }
    useRender(() => {
      const confirmEditProps = VConfirmEdit.filterProps(props);
      const datePickerProps = VDatePicker.filterProps(omit(props, ["active", "location", "rounded"]));
      const datePickerSlots = pick(slots, ["title", "header", "day", "month", "year"]);
      const textFieldProps = VTextField.filterProps(omit(props, ["placeholder"]));
      return createVNode(VTextField, mergeProps({
        "ref": vTextFieldRef
      }, textFieldProps, {
        "class": props.class,
        "style": props.style,
        "modelValue": display.value,
        "inputmode": inputmode.value,
        "placeholder": props.placeholder ?? parserFormat.value,
        "readonly": isReadonly.value,
        "onKeydown": isInteractive.value ? onKeydown : void 0,
        "focused": menu.value || isFocused.value,
        "onBlur": onBlur,
        "validationValue": model.value,
        "onClick:control": isInteractive.value ? onClick : void 0,
        "onClick:prepend": isInteractive.value ? onClick : void 0,
        "onUpdate:modelValue": onUpdateDisplayModel,
        "onUpdate:focused": (event) => isFocused.value = event
      }), {
        ...slots,
        default: () => createBaseVNode(Fragment, null, [createVNode(VMenu, {
          "modelValue": menu.value,
          "onUpdate:modelValue": ($event) => menu.value = $event,
          "activator": "parent",
          "minWidth": "0",
          "eager": isFocused.value,
          "location": props.location,
          "closeOnContentClick": false,
          "openOnClick": false
        }, {
          default: () => [createVNode(VConfirmEdit, mergeProps(confirmEditProps, {
            "modelValue": model.value,
            "onUpdate:modelValue": ($event) => model.value = $event,
            "disabled": disabledActions.value,
            "onSave": onSave,
            "onCancel": onCancel
          }), {
            default: (_ref3) => {
              let {
                actions,
                model: proxyModel,
                save,
                cancel,
                isPristine
              } = _ref3;
              function onUpdateModel(value) {
                if (!props.hideActions) {
                  proxyModel.value = value;
                } else {
                  model.value = value;
                  if (!props.multiple) {
                    menu.value = false;
                  }
                }
                emit("save", value);
                disabledActions.value = [];
              }
              return createVNode(VDatePicker, mergeProps(datePickerProps, {
                "modelValue": props.hideActions ? model.value : proxyModel.value,
                "onUpdate:modelValue": (value) => onUpdateModel(value),
                "onMousedown": (e) => e.preventDefault()
              }), {
                ...datePickerSlots,
                actions: !props.hideActions ? () => slots.actions?.({
                  save,
                  cancel,
                  isPristine
                }) ?? actions() : void 0
              });
            }
          })]
        }), slots.default?.()])
      });
    });
    return forwardRefs({}, vTextFieldRef);
  }
});

// node_modules/vuetify/lib/labs/VFileUpload/VFileUpload.js
import "C:/Users/islam/source/HRMS/client/node_modules/vuetify/lib/labs/VFileUpload/VFileUpload.css";

// node_modules/vuetify/lib/labs/VFileUpload/VFileUploadItem.js
var makeVFileUploadItemProps = propsFactory({
  clearable: Boolean,
  file: {
    type: Object,
    default: null
  },
  fileIcon: {
    type: String,
    // TODO: setup up a proper aliased icon
    default: "mdi-file-document"
  },
  showSize: Boolean,
  ...makeVListItemProps({
    border: true,
    rounded: true,
    lines: "two"
  })
}, "VFileUploadItem");
var VFileUploadItem = genericComponent()({
  name: "VFileUploadItem",
  props: makeVFileUploadItemProps(),
  emits: {
    "click:remove": () => true,
    click: (e) => true
  },
  setup(props, _ref) {
    let {
      emit,
      slots
    } = _ref;
    const preview = ref();
    const base = computed(() => typeof props.showSize !== "boolean" ? props.showSize : void 0);
    function onClickRemove() {
      emit("click:remove");
    }
    watchEffect(() => {
      preview.value = props.file?.type.startsWith("image") ? URL.createObjectURL(props.file) : void 0;
    });
    useRender(() => {
      const listItemProps = VListItem.filterProps(props);
      return createVNode(VListItem, mergeProps(listItemProps, {
        "class": ["v-file-upload-item", props.class],
        "title": props.title ?? props.file?.name,
        "subtitle": props.showSize ? humanReadableFileSize(props.file?.size, base.value) : props.file?.type,
        "style": props.style
      }), {
        ...slots,
        title: slots.title ?? (() => props?.title ?? props.file?.name),
        prepend: (slotProps) => createBaseVNode(Fragment, null, [!slots.prepend ? createVNode(VAvatar, {
          "icon": props.fileIcon,
          "image": preview.value,
          "rounded": true
        }, null) : createVNode(VDefaultsProvider, {
          "defaults": {
            VAvatar: {
              image: preview.value,
              icon: !preview.value ? props.fileIcon : void 0,
              rounded: true
            }
          }
        }, {
          default: () => [slots.prepend?.(slotProps) ?? createVNode(VAvatar, null, null)]
        })]),
        append: (slotProps) => createBaseVNode(Fragment, null, [props.clearable && createBaseVNode(Fragment, null, [!slots.clear ? createVNode(VBtn, {
          "icon": "$clear",
          "density": "comfortable",
          "variant": "text",
          "onClick": onClickRemove
        }, null) : createVNode(VDefaultsProvider, {
          "defaults": {
            VBtn: {
              icon: "$clear",
              density: "comfortable",
              variant: "text"
            }
          }
        }, {
          default: () => [slots.clear?.({
            ...slotProps,
            props: {
              onClick: onClickRemove
            }
          }) ?? createVNode(VBtn, null, null)]
        })]), slots.append?.(slotProps)])
      });
    });
  }
});

// node_modules/vuetify/lib/labs/VFileUpload/VFileUpload.js
var makeVFileUploadProps = propsFactory({
  browseText: {
    type: String,
    default: "$vuetify.fileUpload.browse"
  },
  dividerText: {
    type: String,
    default: "$vuetify.fileUpload.divider"
  },
  title: {
    type: String,
    default: "$vuetify.fileUpload.title"
  },
  subtitle: String,
  icon: {
    type: IconValue,
    default: "$upload"
  },
  modelValue: {
    type: [Array, Object],
    default: null,
    validator: (val) => {
      return wrapInArray(val).every((v) => v != null && typeof v === "object");
    }
  },
  clearable: Boolean,
  disabled: Boolean,
  hideBrowse: Boolean,
  multiple: Boolean,
  scrim: {
    type: [Boolean, String],
    default: true
  },
  showSize: Boolean,
  name: String,
  ...makeFileFilterProps(),
  ...makeDelayProps(),
  ...makeDensityProps(),
  ...pick(makeVDividerProps({
    length: 150
  }), ["length", "thickness", "opacity"]),
  ...makeVSheetProps()
}, "VFileUpload");
var VFileUpload = genericComponent()({
  name: "VFileUpload",
  inheritAttrs: false,
  props: makeVFileUploadProps(),
  emits: {
    "update:modelValue": (files) => true,
    rejected: (files) => true
  },
  setup(props, _ref) {
    let {
      attrs,
      emit,
      slots
    } = _ref;
    const {
      t
    } = useLocale();
    const {
      densityClasses
    } = useDensity(props);
    const {
      filterAccepted
    } = useFileFilter(props);
    const model = useProxiedModel(props, "modelValue", props.modelValue, (val) => wrapInArray(val), (val) => props.multiple || Array.isArray(props.modelValue) ? val : val[0]);
    const isDragging = shallowRef(false);
    const vSheetRef = ref(null);
    const inputRef = ref(null);
    const {
      handleDrop
    } = useFileDrop();
    function onDragover(e) {
      e.preventDefault();
      e.stopImmediatePropagation();
      isDragging.value = true;
    }
    function onDragleave(e) {
      e.preventDefault();
      isDragging.value = false;
    }
    async function onDrop(e) {
      e.preventDefault();
      e.stopImmediatePropagation();
      isDragging.value = false;
      if (!inputRef.value) return;
      const allDroppedFiles = await handleDrop(e);
      selectAccepted(allDroppedFiles);
    }
    function onFileSelection(e) {
      if (!e.target || e.repack) return;
      if (!props.filterByType) {
        const target = e.target;
        model.value = [...target.files ?? []];
      } else {
        selectAccepted([...e.target.files]);
      }
    }
    function selectAccepted(files) {
      const dataTransfer = new DataTransfer();
      const {
        accepted,
        rejected
      } = filterAccepted(files);
      if (rejected.length) {
        emit("rejected", rejected);
      }
      for (const file of accepted) {
        dataTransfer.items.add(file);
      }
      inputRef.value.files = dataTransfer.files;
      model.value = [...dataTransfer.files];
      const event = new Event("change", {
        bubbles: true
      });
      event.repack = true;
      inputRef.value.dispatchEvent(event);
    }
    function onClick() {
      inputRef.value?.click();
    }
    function onClickRemove(index) {
      const newValue = model.value.filter((_, i) => i !== index);
      model.value = newValue;
      if (newValue.length > 0 || !inputRef.value) return;
      inputRef.value.value = "";
    }
    useRender(() => {
      const hasTitle = !!(slots.title || props.title);
      const hasIcon = !!(slots.icon || props.icon);
      const hasBrowse = !!(!props.hideBrowse && (slots.browse || props.density === "default"));
      const cardProps = VSheet.filterProps(props);
      const dividerProps = VDivider.filterProps(props);
      const [rootAttrs, inputAttrs] = filterInputAttrs(attrs);
      const expectsDirectory = attrs.webkitdirectory !== void 0 && attrs.webkitdirectory !== false;
      const acceptFallback = attrs.accept ? String(attrs.accept) : void 0;
      const inputAccept = expectsDirectory ? void 0 : props.filterByType ?? acceptFallback;
      const inputNode = createBaseVNode("input", mergeProps({
        "ref": inputRef,
        "type": "file",
        "accept": inputAccept,
        "disabled": props.disabled,
        "multiple": props.multiple,
        "name": props.name,
        "onChange": onFileSelection
      }, inputAttrs), null);
      return createBaseVNode(Fragment, null, [createVNode(VSheet, mergeProps({
        "ref": vSheetRef
      }, cardProps, {
        "class": ["v-file-upload", {
          "v-file-upload--clickable": !hasBrowse,
          "v-file-upload--disabled": props.disabled,
          "v-file-upload--dragging": isDragging.value
        }, densityClasses.value, props.class],
        "style": [props.style],
        "onDragleave": onDragleave,
        "onDragover": onDragover,
        "onDrop": onDrop,
        "onClick": !hasBrowse ? onClick : void 0
      }, rootAttrs), {
        default: () => [hasIcon && createBaseVNode("div", {
          "key": "icon",
          "class": "v-file-upload-icon"
        }, [!slots.icon ? createVNode(VIcon, {
          "key": "icon-icon",
          "icon": props.icon
        }, null) : createVNode(VDefaultsProvider, {
          "key": "icon-defaults",
          "defaults": {
            VIcon: {
              icon: props.icon
            }
          }
        }, {
          default: () => [slots.icon()]
        })]), hasTitle && createBaseVNode("div", {
          "key": "title",
          "class": "v-file-upload-title"
        }, [slots.title?.() ?? t(props.title)]), props.density === "default" && createBaseVNode(Fragment, null, [createBaseVNode("div", {
          "key": "upload-divider",
          "class": "v-file-upload-divider"
        }, [slots.divider?.() ?? createVNode(VDivider, dividerProps, {
          default: () => [t(props.dividerText)]
        })]), hasBrowse && createBaseVNode(Fragment, null, [!slots.browse ? createVNode(VBtn, {
          "readonly": props.disabled,
          "size": "large",
          "text": t(props.browseText),
          "variant": "tonal",
          "onClick": onClick
        }, null) : createVNode(VDefaultsProvider, {
          "defaults": {
            VBtn: {
              readonly: props.disabled,
              size: "large",
              text: t(props.browseText),
              variant: "tonal"
            }
          }
        }, {
          default: () => [slots.browse({
            props: {
              onClick
            }
          })]
        })]), props.subtitle && createBaseVNode("div", {
          "class": "v-file-upload-subtitle"
        }, [props.subtitle])]), createVNode(VOverlay, {
          "modelValue": isDragging.value,
          "contained": true,
          "scrim": props.scrim
        }, null), slots.input?.({
          inputNode
        }) ?? inputNode]
      }), model.value.length > 0 && createBaseVNode("div", {
        "class": "v-file-upload-items"
      }, [model.value.map((file, i) => {
        const slotProps = {
          file,
          props: {
            "onClick:remove": () => onClickRemove(i)
          }
        };
        return createVNode(VDefaultsProvider, {
          "key": i,
          "defaults": {
            VFileUploadItem: {
              file,
              clearable: props.clearable,
              disabled: props.disabled,
              showSize: props.showSize
            }
          }
        }, {
          default: () => [slots.item?.(slotProps) ?? createVNode(VFileUploadItem, {
            "key": i,
            "onClick:remove": () => onClickRemove(i)
          }, slots)]
        });
      })])]);
    });
  }
});

// node_modules/vuetify/lib/labs/VMaskInput/VMaskInput.js
var makeVMaskInputProps = propsFactory({
  returnMaskedValue: Boolean,
  ...makeVTextFieldProps(),
  ...makeMaskProps()
}, "VMaskInput");
var VMaskInput = genericComponent()({
  name: "VMaskInput",
  props: makeVMaskInputProps(),
  emits: {
    "update:modelValue": (val) => true
  },
  setup(props, _ref) {
    let {
      slots,
      emit
    } = _ref;
    const vTextFieldRef = ref();
    const inputAction = shallowRef();
    const caretPosition = shallowRef(0);
    const mask = useMask(props);
    const returnMaskedValue = computed(() => props.mask && props.returnMaskedValue);
    const model = useProxiedModel(
      props,
      "modelValue",
      void 0,
      // Always display masked value in input when mask is applied
      (val) => props.mask ? mask.mask(mask.unmask(val)) : val,
      (val) => {
        if (props.mask) {
          const valueWithoutDelimiters = removeMaskDelimiters(val);
          const newMaskedValue = mask.mask(valueWithoutDelimiters);
          const newUnmaskedValue = mask.unmask(newMaskedValue);
          const newCaretPosition = getNewCaretPosition({
            oldValue: model.value,
            newValue: newMaskedValue,
            oldCaret: caretPosition.value
          });
          vTextFieldRef.value.value = newMaskedValue;
          vTextFieldRef.value.setSelectionRange(newCaretPosition, newCaretPosition);
          return returnMaskedValue.value ? mask.mask(newUnmaskedValue) : newUnmaskedValue;
        }
        return val;
      }
    );
    const validationValue = toRef(() => returnMaskedValue.value ? model.value : mask.unmask(model.value));
    function removeMaskDelimiters(val) {
      return val.split("").filter((ch) => !isMaskDelimiter(ch)).join("");
    }
    function getNewCaretPosition(_ref2) {
      let {
        oldValue,
        newValue,
        oldCaret
      } = _ref2;
      if (!newValue) return 0;
      if (!oldValue) return newValue.length;
      let newCaret;
      if (inputAction.value === "Backspace") {
        newCaret = oldCaret - 1;
        while (newCaret > 0 && isMaskDelimiter(newValue[newCaret - 1])) newCaret--;
      } else if (inputAction.value === "Delete") {
        newCaret = oldCaret;
      } else {
        newCaret = oldCaret + 1;
        while (isMaskDelimiter(newValue[newCaret])) newCaret++;
        if (isMaskDelimiter(newValue[oldCaret])) newCaret++;
      }
      return newCaret;
    }
    onBeforeMount(() => {
      if (props.returnMaskedValue) {
        emit("update:modelValue", model.value);
      }
    });
    function onKeyDown(e) {
      if (e.metaKey) return;
      const inputElement = e.target;
      caretPosition.value = inputElement.selectionStart || 0;
      inputAction.value = e.key;
      const hasSelection = inputElement.selectionStart !== inputElement.selectionEnd;
      if (e.key === "Backspace" && hasSelection) {
        e.preventDefault();
        deleteSelection(e);
      }
    }
    async function onCut(e) {
      e.preventDefault();
      copySelectionToClipboard(e);
      deleteSelection(e);
    }
    async function onPaste(e) {
      e.preventDefault();
      const inputElement = e.target;
      const pastedString = removeMaskDelimiters(e.clipboardData?.getData("text") || "");
      if (!pastedString) return;
      const pastedCharacters = [...pastedString];
      const hasSelection = inputElement.selectionStart !== inputElement.selectionEnd;
      if (hasSelection) {
        replaceSelection(inputElement, pastedCharacters);
      } else {
        insertCharacters(inputElement, pastedCharacters);
      }
    }
    function copySelectionToClipboard(e) {
      const inputElement = e.target;
      const start = inputElement.selectionStart || 0;
      const end = inputElement.selectionEnd || 0;
      const selectedText = inputElement.value.substring(start, end);
      navigator.clipboard.writeText(selectedText);
    }
    async function deleteSelection(e) {
      const inputElement = e.target;
      const curStart = inputElement.selectionStart || 0;
      caretPosition.value = inputElement.selectionEnd || 0;
      while (caretPosition.value > curStart) {
        const success = await simulateBackspace(inputElement);
        if (!success) break;
      }
    }
    async function simulateBackspace(inputElement) {
      inputAction.value = "Backspace";
      model.value = inputElement.value.slice(0, caretPosition.value - 1) + inputElement.value.slice(caretPosition.value);
      inputAction.value = "";
      if (caretPosition.value === inputElement.selectionEnd) return false;
      caretPosition.value = inputElement.selectionEnd || 0;
      await nextTick();
      return true;
    }
    async function insertCharacters(inputElement, pastedCharacters) {
      for (let i = 0; i < pastedCharacters.length; i++) {
        await insertCharacter(inputElement, pastedCharacters[i]);
      }
    }
    async function insertCharacter(inputElement, character) {
      caretPosition.value = inputElement.selectionEnd || 0;
      model.value = inputElement.value.slice(0, caretPosition.value) + character + inputElement.value.slice(caretPosition.value);
      await nextTick();
    }
    async function replaceSelection(inputElement, pastedCharacters) {
      caretPosition.value = inputElement.selectionStart || 0;
      for (let i = 0; i < pastedCharacters.length; i++) {
        await replaceCharacter(caretPosition.value, pastedCharacters[i]);
        caretPosition.value++;
      }
    }
    async function replaceCharacter(index, character) {
      let targetIndex = index;
      while (targetIndex < model.value.length && isMaskDelimiter(model.value[targetIndex])) targetIndex++;
      model.value = model.value.slice(0, targetIndex) + character + model.value.slice(targetIndex + 1);
      await nextTick();
    }
    useRender(() => {
      const textFieldProps = VTextField.filterProps(props);
      return createVNode(VTextField, mergeProps(textFieldProps, {
        "modelValue": model.value,
        "onUpdate:modelValue": ($event) => model.value = $event,
        "ref": vTextFieldRef,
        "validationValue": validationValue.value,
        "onCut": onCut,
        "onPaste": onPaste,
        "onKeydown": onKeyDown
      }), {
        ...slots
      });
    });
    return forwardRefs({}, vTextFieldRef);
  }
});

// node_modules/vuetify/lib/labs/VPie/VPie.js
import "C:/Users/islam/source/HRMS/client/node_modules/vuetify/lib/labs/VPie/VPie.css";

// node_modules/vuetify/lib/composables/reveal.js
var makeRevealProps = propsFactory({
  reveal: {
    type: [Boolean, Object],
    default: false
  }
}, "reveal");
function useReveal(props) {
  const defaultDuration = 900;
  const duration = toRef(() => typeof props.reveal === "object" ? Math.max(0, Number(props.reveal.duration ?? defaultDuration)) : defaultDuration);
  const state = shallowRef(props.reveal ? "initial" : "disabled");
  onMounted(async () => {
    if (props.reveal) {
      state.value = "initial";
      await new Promise((resolve) => requestAnimationFrame(resolve));
      state.value = "pending";
      await new Promise((resolve) => setTimeout(resolve, duration.value));
      state.value = "done";
    }
  });
  return {
    duration,
    state
  };
}

// node_modules/vuetify/lib/util/svg-arc-corners.js
function pointOnArc(center, radius, angle) {
  const radians = (angle - 90) * Math.PI / 180;
  return [center[0] + radius * Math.cos(radians), center[1] + radius * Math.sin(radians)];
}
function drawCircle(_ref, r, width) {
  let [x, y] = _ref;
  const innerRadius = r - width;
  return ["M", x - r, y, "A", r, r, 0, 1, 0, x + r, y, "A", r, r, 0, 1, 0, x - r, y, "M", x - innerRadius, y, "A", innerRadius, innerRadius, 0, 1, 0, x + innerRadius, y, "A", innerRadius, innerRadius, 0, 1, 0, x - innerRadius, y, "Z"];
}
function simpleArc(center, r, startAngle, endAngle) {
  const start = pointOnArc(center, r, startAngle);
  const end = pointOnArc(center, r, endAngle);
  const sweep = endAngle - startAngle > 180 ? 1 : 0;
  return [`M${start[0]} ${start[1]}`, `A${r} ${r} 0 ${sweep} 1 ${end[0]} ${end[1]}`, `L${center[0]} ${center[1]}Z`].join(" ");
}
function roundedArc(center, radius, startAngle, endAngle, width, rounding) {
  width = Math.min(radius, width);
  if (Math.abs(endAngle - startAngle) === 360) {
    return drawCircle(center, radius, width).join(" ");
  }
  if (rounding === 0 && radius === width) {
    return simpleArc(center, radius, startAngle, endAngle);
  }
  const innerR = radius - width;
  const circumference = Math.abs(endAngle - startAngle);
  rounding = Math.min(width / 2, rounding);
  if (360 * (rounding / (Math.PI * (radius - width))) > Math.abs(startAngle - endAngle)) {
    rounding = circumference / 360 * innerR * Math.PI;
  }
  const innerR2 = innerR + rounding;
  const outerRadius = radius - rounding;
  const oStart = pointOnArc(center, outerRadius, startAngle);
  const oEnd = pointOnArc(center, outerRadius, endAngle);
  const iStart = pointOnArc(center, innerR2, startAngle);
  const iEnd = pointOnArc(center, innerR2, endAngle);
  const iSection = innerR ? 360 * (rounding / (2 * Math.PI * innerR)) : 0;
  const oSection = 360 * (rounding / (2 * Math.PI * radius));
  const iArcStart = pointOnArc(center, innerR, startAngle + iSection);
  const iArcEnd = pointOnArc(center, innerR, endAngle - iSection);
  const oArcStart = pointOnArc(center, radius, startAngle + oSection);
  const oArcEnd = pointOnArc(center, radius, endAngle - oSection);
  const arcSweep1 = circumference > 180 + 2 * oSection ? 1 : 0;
  const arcSweep2 = circumference > 180 + 2 * iSection ? 1 : 0;
  return [
    // begin path
    "M",
    oStart[0],
    oStart[1],
    // outer start corner
    "A",
    rounding,
    rounding,
    0,
    0,
    1,
    oArcStart[0],
    oArcStart[1],
    // outer main arc
    "A",
    radius,
    radius,
    0,
    arcSweep1,
    1,
    oArcEnd[0],
    oArcEnd[1],
    // outer end corner
    "A",
    rounding,
    rounding,
    0,
    0,
    1,
    oEnd[0],
    oEnd[1],
    // end butt
    "L",
    iEnd[0],
    iEnd[1],
    // inner end corner
    "A",
    rounding,
    rounding,
    0,
    0,
    1,
    iArcEnd[0],
    iArcEnd[1],
    // inner arc
    "A",
    innerR,
    innerR,
    0,
    arcSweep2,
    0,
    iArcStart[0],
    iArcStart[1],
    // inner start corner
    "A",
    rounding,
    rounding,
    0,
    0,
    1,
    iStart[0],
    iStart[1],
    "Z"
    // end path
  ].join(" ");
}

// node_modules/vuetify/lib/labs/VPie/utils.js
function formatTextTemplate(template, item) {
  return item ? template.replaceAll("[title]", item.title).replaceAll("[value]", String(item.value)) : void 0;
}
function usePieArc(props, isHovering) {
  const hoverZoomRatio = toRef(() => clamp(Number(props.hoverScale ?? 0), 0, 0.25));
  const normalizedValue = toRef(() => clamp(props.value - 100 * Number(props.gap ?? 0) / 360, 0.01, 99.99));
  const normalizedInnerCut = toRef(() => {
    const min = Number(props.rounded ?? 0) > 0 ? 0.2 : 0;
    return clamp(Number(props.innerCut ?? 0) / 100, min, 1);
  });
  const radians = computed(() => (360 * (-normalizedValue.value / 100) + 90) * (Math.PI / 180));
  const arcWidth = computed(() => 50 * (1 - normalizedInnerCut.value) * (isHovering.value ? 1 : 1 - hoverZoomRatio.value));
  const outerX = toRef(() => 50 + 50 * Math.cos(radians.value));
  const outerY = toRef(() => 50 - 50 * Math.sin(radians.value));
  return {
    hoverZoomRatio,
    normalizedValue,
    normalizedInnerCut,
    outerX,
    outerY,
    arcWidth
  };
}
function useOuterSlicePath(_ref) {
  let {
    angle,
    radius,
    size,
    width,
    rounded
  } = _ref;
  return computed(() => roundedArc(
    [50, 50],
    toValue(radius),
    toValue(angle),
    toValue(angle) + 360 * toValue(size) / 100,
    // angle end,
    toValue(width),
    toValue(rounded)
  ));
}
function useInnerSlicePath(_ref2) {
  let {
    angle,
    radius,
    size
  } = _ref2;
  return computed(() => simpleArc(
    [50, 50],
    toValue(radius),
    toValue(angle),
    toValue(angle) + 360 * toValue(size) / 100
    // angle end,
  ));
}

// node_modules/vuetify/lib/labs/VPie/VPieSegment.js
var makeVPieSegmentProps = propsFactory({
  active: Boolean,
  rotate: [Number, String],
  value: {
    type: Number,
    default: 0
  },
  color: String,
  innerCut: [Number, String],
  hoverScale: {
    type: [Number, String],
    default: 0.05
  },
  gap: [Number, String],
  rounded: [Number, String],
  animation: {
    type: [Boolean, Object],
    default: false
  },
  pattern: String,
  hideSlice: Boolean,
  ...makeRevealProps()
}, "VPieSegment");
var VPieSegment = genericComponent()({
  name: "VPieSegment",
  props: makeVPieSegmentProps(),
  emits: {
    "update:active": (val) => true
  },
  setup(props) {
    const isActive = useProxiedModel(props, "active");
    const {
      state: revealState,
      duration: revealDuration
    } = useReveal(props);
    const transitionConfig = computed(() => {
      const defaultEasing = "easeInOutCubic";
      const defaultDuration = 400;
      const easingName = typeof props.animation === "object" ? props.animation.easing ?? defaultEasing : defaultEasing;
      return {
        duration: ["initial", "pending"].includes(revealState.value) ? revealDuration.value : typeof props.animation === "object" ? props.animation.duration : props.animation ? defaultDuration : 0,
        transition: easingPatterns[easingName]
      };
    });
    const {
      hoverZoomRatio,
      normalizedValue,
      normalizedInnerCut,
      outerX,
      outerY,
      arcWidth
    } = usePieArc(props, isActive);
    const arcSize = toRef(() => revealState.value === "initial" ? 0 : normalizedValue.value);
    const currentArcSize = useTransition(arcSize, transitionConfig);
    const angle = toRef(() => revealState.value === "initial" ? 0 : Number(props.rotate ?? 0) + Number(props.gap ?? 0) / 2);
    const currentAngle = useTransition(angle, transitionConfig);
    const arcRadius = toRef(() => 50 * (isActive.value ? 1 : 1 - hoverZoomRatio.value));
    const currentArcRadius = useTransition(arcRadius, transitionConfig);
    const currentArcWidth = useTransition(arcWidth, transitionConfig);
    const outerSlicePath = useOuterSlicePath({
      angle: currentAngle,
      radius: currentArcRadius,
      size: currentArcSize,
      width: currentArcWidth,
      rounded: () => Number(props.rounded ?? 0)
    });
    const innerSlicePath = useInnerSlicePath({
      angle: currentAngle,
      radius: () => currentArcRadius.value - currentArcWidth.value,
      size: currentArcSize
    });
    const overlayPath = toRef(() => `M 50 0 A 50 50 0 ${normalizedValue.value > 50 ? 1 : 0} 1 ${outerX.value} ${outerY.value} L 50 50`);
    return () => createBaseVNode("g", {
      "class": "v-pie-segment",
      "style": {
        color: props.color
      }
    }, [createBaseVNode("path", {
      "key": "outer-slice",
      "fill": "currentColor",
      "shape-rendering": "geometricPrecision",
      "d": outerSlicePath.value
    }, null), props.pattern && createBaseVNode("path", {
      "key": "pattern-overlay",
      "shape-rendering": "geometricPrecision",
      "fill": props.pattern,
      "d": outerSlicePath.value
    }, null), !props.hideSlice && normalizedInnerCut.value > 0 && createBaseVNode("path", {
      "key": "inner-slice",
      "fill": "oklch(from currentColor l c h / calc(alpha / 2))",
      "d": innerSlicePath.value
    }, null), ["disabled", "done"].includes(revealState.value) && createBaseVNode("path", {
      "transform": `rotate(${currentAngle.value} 50 50)`,
      "class": "v-pie-segment__overlay",
      "d": overlayPath.value,
      "onMouseenter": () => isActive.value = true,
      "onMouseleave": () => isActive.value = false
    }, null)]);
  }
});

// node_modules/vuetify/lib/labs/VPie/VPieTooltip.js
var makeVPieTooltipProps = propsFactory({
  modelValue: Boolean,
  target: Object,
  item: {
    type: Object,
    default: null
  },
  titleFormat: {
    type: [String, Function],
    default: "[title]"
  },
  subtitleFormat: {
    type: [String, Function],
    default: "[value]"
  },
  ...makeTransitionProps(),
  ...pick(makeVTooltipProps(), ["offset"])
}, "VPieTooltip");
var VPieTooltip = genericComponent()({
  name: "VPieTooltip",
  props: makeVPieTooltipProps(),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const tooltipTitleFormatFunction = toRef(() => (segment) => {
      return typeof props.titleFormat === "function" ? props.titleFormat(segment) : formatTextTemplate(props.titleFormat, segment);
    });
    const tooltipSubtitleFormatFunction = toRef(() => (segment) => {
      return typeof props.subtitleFormat === "function" ? props.subtitleFormat(segment) : formatTextTemplate(props.subtitleFormat, segment);
    });
    return () => createVNode(VTooltip, {
      "offset": props.offset,
      "modelValue": props.modelValue,
      "target": props.target,
      "contentClass": "v-pie__tooltip-content"
    }, {
      default: () => [!!props.item && (slots.default?.({
        item: props.item
      }) ?? createVNode(MaybeTransition, {
        "transition": props.transition,
        "mode": "out-in"
      }, {
        default: () => [createVNode(VListItem, {
          "key": props.item.key,
          "density": "compact",
          "title": tooltipTitleFormatFunction.value(props.item),
          "subtitle": tooltipSubtitleFormatFunction.value(props.item)
        }, {
          prepend: slots.prepend ? () => slots.prepend({
            item: props.item
          }) : void 0
        })]
      }))]
    });
  }
});

// node_modules/vuetify/lib/labs/VPie/VPie.js
var makeVPieProps = propsFactory({
  title: String,
  bgColor: String,
  items: {
    type: Array,
    default: () => []
  },
  palette: {
    type: Array,
    default: () => []
  },
  itemKey: {
    type: String,
    default: "key"
  },
  itemValue: {
    type: String,
    default: "value"
  },
  itemTitle: {
    type: String,
    default: "title"
  },
  size: {
    type: [Number, String],
    default: 250
  },
  rotate: [Number, String],
  gaugeCut: [Number, String],
  legend: {
    type: [Boolean, Object],
    default: false
  },
  tooltip: {
    type: [Boolean, Object],
    default: false
  },
  ...makeDensityProps(),
  ...pick(makeVPieSegmentProps(), ["animation", "gap", "rounded", "innerCut", "hoverScale", "hideSlice", "reveal"])
}, "VPie");
var VPie = genericComponent()({
  name: "VPie",
  directives: {
    vClickOutside: click_outside_default
  },
  props: makeVPieProps(),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const legendConfig = computed(() => ({
      visible: !!props.legend,
      position: "bottom",
      textFormat: "[title]",
      ...typeof props.legend === "object" ? props.legend : {}
    }));
    const {
      colorClasses,
      colorStyles
    } = useColor(() => ({
      background: props.bgColor
    }));
    const textColorStyles = toRef(() => pick(colorStyles.value, ["color", "caretColor"]));
    const legendAvatarSize = toRef(() => ({
      default: 20,
      comfortable: 18,
      compact: 16
    })[props.density ?? "default"]);
    const legendDirection = toRef(() => ["left", "right"].includes(legendConfig.value.position) ? "vertical" : "horizontal");
    const legendMode = toRef(() => !legendConfig.value.visible ? "hidden" : legendConfig.value.position);
    const legendTextFormatFunction = toRef(() => (item) => {
      return typeof legendConfig.value.textFormat === "function" ? legendConfig.value.textFormat(item) : formatTextTemplate(legendConfig.value.textFormat, item);
    });
    const arcs = computed(() => {
      return props.items.filter(Boolean).map((item, index) => {
        return {
          key: item[props.itemKey],
          color: item.color ?? colorFromPalette(index),
          value: item[props.itemValue],
          title: String(item[props.itemTitle]),
          pattern: item.pattern ?? patternFromPalette(index),
          raw: item
        };
      });
    });
    const visibleItemsKeys = shallowRef([]);
    watch(() => arcs.value.length, () => {
      visibleItemsKeys.value = arcs.value.map((a) => a.key);
    }, {
      immediate: true
    });
    const visibleItems = computed(() => {
      return arcs.value.map((item) => {
        return isVisible(item) ? item : {
          ...item,
          value: 0
        };
      });
    });
    const total = computed(() => visibleItems.value.reduce((sum, item) => sum + item.value, 0));
    const gaugeCut = toRef(() => Number(props.gaugeCut ?? 0));
    const gaugeOffset = computed(() => (1 - Math.cos(Math.PI * Math.min(90, gaugeCut.value / 2) / 180)) / 2);
    const rotateDeg = computed(() => `${gaugeCut.value ? 180 + gaugeCut.value / 2 : props.rotate ?? 0}deg`);
    function arcOffset(index) {
      return visibleItems.value.slice(0, index).reduce((acc, s) => acc + (total.value > 0 ? s.value / total.value : 0) * (360 - gaugeCut.value), 0);
    }
    function arcSize(v) {
      return v / total.value * (100 - gaugeCut.value / 3.6);
    }
    function colorFromPalette(index) {
      if (props.palette.length === 0) return void 0;
      const paletteItem = props.palette[index % props.palette.length];
      return typeof paletteItem === "object" ? paletteItem.color : paletteItem;
    }
    function patternFromPalette(index) {
      if (props.palette.length === 0) return void 0;
      const paletteItem = props.palette[index % props.palette.length];
      return typeof paletteItem === "object" ? paletteItem.pattern : void 0;
    }
    function isVisible(item) {
      return visibleItemsKeys.value.includes(item.key);
    }
    function toggle(item) {
      if (isVisible(item)) {
        visibleItemsKeys.value = visibleItemsKeys.value.filter((x) => x !== item.key);
      } else {
        visibleItemsKeys.value = [...visibleItemsKeys.value, item.key];
      }
    }
    const tooltipItem = shallowRef(null);
    const tooltipVisible = shallowRef(false);
    const tooltipTarget = shallowRef([0, 0]);
    let mouseLeaveTimeout = null;
    function setItemActive(item, active) {
      arcs.value.forEach((a) => a.isActive = a.key === item.key && active);
      if (props.tooltip) {
        setTooltip(item, active);
      }
    }
    function setTooltip(item, active) {
      clearTimeout(mouseLeaveTimeout);
      if (active) {
        tooltipVisible.value = true;
        tooltipItem.value = item;
      } else {
        mouseLeaveTimeout = setTimeout(() => {
          tooltipVisible.value = false;
          mouseLeaveTimeout = setTimeout(() => {
            tooltipItem.value = null;
          }, 500);
        }, 100);
      }
    }
    let frame = -1;
    function onSvgMousemove(_ref2) {
      let {
        clientX,
        clientY
      } = _ref2;
      cancelAnimationFrame(frame);
      frame = requestAnimationFrame(() => {
        tooltipTarget.value = [clientX, clientY];
      });
    }
    function onSvgTouchstart(_ref3) {
      let {
        touches
      } = _ref3;
      if (!touches) return;
      const {
        clientX,
        clientY
      } = touches[0];
      tooltipTarget.value = [clientX, clientY];
    }
    function onSvgClickOutside() {
      arcs.value.forEach((a) => a.isActive = false);
      tooltipVisible.value = false;
    }
    return () => {
      const segmentProps = pick(props, ["animation", "gap", "rounded", "hideSlice", "reveal", "innerCut", "hoverScale"]);
      const defaultTooltipTransition = {
        name: "fade-transition",
        duration: 150
      };
      const tooltipProps = {
        item: tooltipItem.value,
        modelValue: tooltipVisible.value,
        titleFormat: typeof props.tooltip === "object" ? props.tooltip.titleFormat : "[title]",
        subtitleFormat: typeof props.tooltip === "object" ? props.tooltip.subtitleFormat : "[value]",
        transition: typeof props.tooltip === "object" ? props.tooltip.transition : defaultTooltipTransition,
        offset: typeof props.tooltip === "object" ? props.tooltip.offset : 16,
        target: tooltipTarget.value
      };
      const legendDefaults = {
        VChipGroup: {
          direction: legendDirection.value
        },
        VChip: {
          density: props.density
        },
        VAvatar: {
          size: legendAvatarSize.value
        }
      };
      const tooltipDefaults = {
        VAvatar: {
          size: typeof props.tooltip === "object" ? props.tooltip.avatarSize : 28
        }
      };
      const avatarSlot = (_ref4) => {
        let {
          item
        } = _ref4;
        return createVNode(VAvatar, {
          "color": item.color,
          "start": true
        }, {
          default: () => [item.pattern && createBaseVNode("svg", {
            "height": "40",
            "width": "40"
          }, [createBaseVNode("rect", {
            "width": "40",
            "height": "40",
            "fill": item.pattern
          }, null)])]
        });
      };
      return createBaseVNode("div", {
        "class": normalizeClass(["v-pie", `v-pie--legend-${legendMode.value}`]),
        "style": {
          "--v-pie-size": convertToUnit(props.size)
        }
      }, [slots.title?.() ?? (props.title && createBaseVNode("div", {
        "class": "v-pie__title"
      }, [props.title])), createBaseVNode("div", {
        "class": normalizeClass(["v-pie__content", colorClasses.value]),
        "style": normalizeStyle([{
          transform: `rotate(${rotateDeg.value})`,
          marginBottom: `calc(-1 * ${convertToUnit(props.size)} * ${gaugeOffset.value})`
        }, textColorStyles.value])
      }, [createBaseVNode("div", {
        "class": normalizeClass(["v-pie__content-underlay", colorClasses.value]),
        "style": normalizeStyle(colorStyles.value)
      }, null), withDirectives(createBaseVNode("svg", {
        "xmlns": "http://www.w3.org/2000/svg",
        "viewBox": "0 0 100 100",
        "class": "v-pie__segments",
        "onMousemove": onSvgMousemove,
        "onTouchstart": onSvgTouchstart
      }, [arcs.value.map((item, index) => createVNode(VPieSegment, mergeProps(segmentProps, {
        "key": item.key,
        "active": item.isActive,
        "color": item.color,
        "value": isVisible(item) ? arcSize(item.value) : 0,
        "rotate": arcOffset(index),
        "pattern": item.pattern,
        "onUpdate:active": (val) => setItemActive(item, val),
        "onTouchend": () => setItemActive(item, true)
      }), null))]), [[click_outside_default, {
        handler: onSvgClickOutside
      }]]), createBaseVNode("div", {
        "class": "v-pie__center-content",
        "style": {
          transform: `translate(-50%, -50%)
                  rotate(-${rotateDeg.value})
                  translateY(calc(-100% * ${gaugeOffset.value}))`
        }
      }, [createBaseVNode("div", null, [slots.center?.({
        total: total.value
      })])])]), legendConfig.value.visible && createVNode(VDefaultsProvider, {
        "key": "legend",
        "defaults": legendDefaults
      }, {
        default: () => [createBaseVNode("div", {
          "class": "v-pie__legend"
        }, [slots.legend?.({
          isActive: isVisible,
          toggle,
          items: arcs.value,
          total: total.value
        }) ?? createVNode(VChipGroup, {
          "column": true,
          "multiple": true,
          "modelValue": visibleItemsKeys.value,
          "onUpdate:modelValue": ($event) => visibleItemsKeys.value = $event
        }, {
          default: () => [arcs.value.map((item) => createVNode(VChip, {
            "value": item.key
          }, {
            prepend: () => avatarSlot({
              item
            }),
            default: () => createBaseVNode("div", {
              "class": "v-pie__legend__text"
            }, [slots["legend-text"]?.({
              item,
              total: total.value
            }) ?? legendTextFormatFunction.value(item)])
          }))]
        })])]
      }), !!props.tooltip && createVNode(VDefaultsProvider, {
        "defaults": tooltipDefaults
      }, {
        default: () => [createVNode(VPieTooltip, tooltipProps, {
          default: slots.tooltip ? (slotProps) => slots.tooltip?.({
            ...slotProps,
            total: total.value
          }) : void 0,
          prepend: avatarSlot
        })]
      })]);
    };
  }
});

// node_modules/vuetify/lib/labs/VStepperVertical/VStepperVerticalItem.js
import "C:/Users/islam/source/HRMS/client/node_modules/vuetify/lib/labs/VStepperVertical/VStepperVerticalItem.css";

// node_modules/vuetify/lib/labs/VStepperVertical/VStepperVerticalActions.js
var makeVStepperVerticalActionsProps = propsFactory({
  ...makeVStepperActionsProps()
}, "VStepperActions");
var VStepperVerticalActions = genericComponent()({
  name: "VStepperVerticalActions",
  props: makeVStepperVerticalActionsProps(),
  emits: {
    "click:prev": () => true,
    "click:next": () => true
  },
  setup(props, _ref) {
    let {
      emit,
      slots
    } = _ref;
    function onClickPrev() {
      emit("click:prev");
    }
    function onClickNext() {
      emit("click:next");
    }
    useRender(() => {
      const stepperActionsProps = VStepperActions.filterProps(props);
      return createVNode(VStepperActions, mergeProps({
        "class": "v-stepper-vertical-actions"
      }, stepperActionsProps, {
        "onClick:prev": onClickPrev,
        "onClick:next": onClickNext
      }), slots);
    });
    return {};
  }
});

// node_modules/vuetify/lib/labs/VStepperVertical/VStepperVerticalItem.js
var makeVStepperVerticalItemProps = propsFactory({
  hideActions: Boolean,
  ...makeStepperItemProps(),
  ...omit(makeVExpansionPanelProps({
    expandIcon: "",
    collapseIcon: ""
  }), ["hideActions"])
}, "VStepperVerticalItem");
var VStepperVerticalItem = genericComponent()({
  name: "VStepperVerticalItem",
  props: makeVStepperVerticalItemProps(),
  emits: {
    "click:next": () => true,
    "click:prev": () => true,
    "click:finish": () => true
  },
  setup(props, _ref) {
    let {
      emit,
      slots
    } = _ref;
    const vExpansionPanelRef = ref();
    const step = computed(() => !isNaN(parseInt(props.value)) ? Number(props.value) : props.value);
    const groupItem = computed(() => vExpansionPanelRef.value?.groupItem);
    const isSelected = computed(() => groupItem.value?.isSelected.value ?? false);
    const isValid = computed(() => isSelected.value ? props.rules.every((handler) => handler() === true) : null);
    const canEdit = computed(() => !props.disabled && props.editable);
    const hasError = computed(() => props.error || isSelected.value && !isValid.value);
    const hasCompleted = computed(() => props.complete || props.rules.length > 0 && isValid.value === true);
    const disabled = computed(() => {
      if (props.disabled) return props.disabled;
      if (groupItem.value?.isFirst.value) return "prev";
      return false;
    });
    const icon = computed(() => {
      if (hasError.value) return props.errorIcon;
      if (hasCompleted.value) return props.completeIcon;
      if (groupItem.value?.isSelected.value && props.editable) return props.editIcon;
      return props.icon;
    });
    const slotProps = computed(() => ({
      canEdit: canEdit.value,
      hasError: hasError.value,
      hasCompleted: hasCompleted.value,
      title: props.title,
      subtitle: props.subtitle,
      step: step.value
    }));
    const actionProps = computed(() => ({
      ...slotProps.value,
      prev: onClickPrev,
      next: onClickNext
    }));
    function onClickNext() {
      emit("click:next");
      if (groupItem.value?.isLast.value) return;
      groupItem.value.group.next();
    }
    function onClickPrev() {
      emit("click:prev");
      groupItem.value.group.prev();
    }
    useRender(() => {
      const hasColor = (hasCompleted.value || groupItem.value?.isSelected.value) && !hasError.value && !props.disabled;
      const hasActions = !props.hideActions || !!slots.actions;
      const expansionPanelProps = VExpansionPanel.filterProps(props);
      return createVNode(VExpansionPanel, mergeProps({
        "_as": "VStepperVerticalItem",
        "ref": vExpansionPanelRef
      }, expansionPanelProps, {
        "class": ["v-stepper-vertical-item", {
          "v-stepper-vertical-item--complete": hasCompleted.value,
          "v-stepper-vertical-item--disabled": props.disabled,
          "v-stepper-vertical-item--editable": canEdit.value,
          "v-stepper-vertical-item--error": hasError.value
        }, props.class],
        "readonly": !props.editable,
        "style": props.style,
        "color": "",
        "hideActions": false,
        "value": step.value
      }), {
        title: () => createBaseVNode(Fragment, null, [createVNode(VAvatar, {
          "key": "stepper-avatar",
          "class": "v-stepper-vertical-item__avatar",
          "color": hasColor ? props.color : void 0,
          "size": 24,
          "start": true
        }, {
          default: () => [slots.icon?.(slotProps.value) ?? (icon.value ? createVNode(VIcon, {
            "icon": icon.value
          }, null) : step.value)]
        }), createBaseVNode("div", null, [createBaseVNode("div", {
          "class": "v-stepper-vertical-item__title"
        }, [slots.title?.(slotProps.value) ?? props.title]), createBaseVNode("div", {
          "class": "v-stepper-vertical-item__subtitle"
        }, [slots.subtitle?.(slotProps.value) ?? props.subtitle])])]),
        text: () => createBaseVNode(Fragment, null, [slots.default?.(slotProps.value) ?? props.text, hasActions && createVNode(VDefaultsProvider, {
          "defaults": {
            VStepperVerticalActions: {
              disabled: disabled.value,
              finish: groupItem.value?.isLast.value
            }
          }
        }, {
          default: () => [slots.actions?.(actionProps.value) ?? createVNode(VStepperVerticalActions, {
            "onClick:next": onClickNext,
            "onClick:prev": onClickPrev
          }, {
            prev: slots.prev ? () => slots.prev?.(actionProps.value) : void 0,
            next: slots.next ? () => slots.next?.(actionProps.value) : void 0
          })]
        })])
      });
    });
    return {};
  }
});

// node_modules/vuetify/lib/labs/VStepperVertical/VStepperVertical.js
var makeVStepperVerticalProps = propsFactory({
  prevText: {
    type: String,
    default: "$vuetify.stepper.prev"
  },
  nextText: {
    type: String,
    default: "$vuetify.stepper.next"
  },
  ...makeStepperProps(),
  ...omit(makeVExpansionPanelsProps({
    mandatory: "force",
    variant: "accordion"
  }), ["static"])
}, "VStepperVertical");
var VStepperVertical = genericComponent()({
  name: "VStepperVertical",
  props: makeVStepperVerticalProps(),
  emits: {
    "update:modelValue": (val) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const vExpansionPanelsRef = ref();
    const {
      color,
      eager,
      editable,
      prevText,
      nextText,
      hideActions
    } = toRefs(props);
    const model = useProxiedModel(props, "modelValue");
    const items = computed(() => props.items.map((item, index) => {
      const title = getPropertyFromItem(item, props.itemTitle, item);
      const value = getPropertyFromItem(item, props.itemValue, index + 1);
      return {
        title,
        value,
        raw: item
      };
    }));
    provideDefaults({
      VStepperVerticalItem: {
        color,
        eager,
        editable,
        hideActions,
        static: true
      },
      VStepperVerticalActions: {
        color,
        nextText,
        prevText
      }
    });
    useRender(() => {
      const expansionPanelProps = VExpansionPanels.filterProps(props);
      return createVNode(VExpansionPanels, mergeProps(expansionPanelProps, {
        "modelValue": model.value,
        "onUpdate:modelValue": ($event) => model.value = $event,
        "ref": vExpansionPanelsRef,
        "class": ["v-stepper", {
          "v-stepper--alt-labels": props.altLabels,
          "v-stepper--flat": props.flat,
          "v-stepper--non-linear": props.nonLinear,
          "v-stepper--mobile": props.mobile
        }, props.class],
        "style": props.style
      }), {
        ...slots,
        default: (_ref2) => {
          let {
            prev,
            next
          } = _ref2;
          return createBaseVNode(Fragment, null, [items.value.map((_ref3) => {
            let {
              raw,
              ...item
            } = _ref3;
            return createVNode(VStepperVerticalItem, item, {
              ...slots,
              default: slots[`item.${item.value}`]
            });
          }), slots.default?.({
            prev,
            next,
            step: model.value
          })]);
        }
      });
    });
    return {};
  }
});

// node_modules/vuetify/lib/labs/VPullToRefresh/VPullToRefresh.js
import "C:/Users/islam/source/HRMS/client/node_modules/vuetify/lib/labs/VPullToRefresh/VPullToRefresh.css";
var VPullToRefresh = genericComponent()({
  name: "VPullToRefresh",
  props: {
    disabled: Boolean,
    pullDownThreshold: {
      type: Number,
      default: 64
    }
  },
  emits: {
    load: (options) => true
  },
  setup(props, _ref) {
    let {
      slots,
      emit
    } = _ref;
    let touchstartY = 0;
    let scrollParents = [];
    const touchDiff = shallowRef(0);
    const containerRef = ref();
    const refreshing = shallowRef(false);
    const goingUp = shallowRef(false);
    const touching = shallowRef(false);
    const canRefresh = computed(() => touchDiff.value >= props.pullDownThreshold && !refreshing.value);
    const topOffset = computed(() => clamp(touchDiff.value, 0, props.pullDownThreshold));
    function onTouchstart(e) {
      if (refreshing.value || props.disabled) return;
      touching.value = true;
      touchstartY = "clientY" in e ? e.clientY : e.touches[0].clientY;
    }
    function onTouchmove(e) {
      if (refreshing.value || !touching.value || props.disabled) return;
      const touchY = "clientY" in e ? e.clientY : e.touches[0].clientY;
      if (scrollParents.length && !scrollParents[0].scrollTop) {
        touchDiff.value = touchY - touchstartY;
      }
    }
    function onTouchend(e) {
      if (refreshing.value || props.disabled) return;
      touching.value = false;
      if (canRefresh.value) {
        let done = function() {
          if (!refreshing.value) return;
          touchDiff.value = 0;
          refreshing.value = false;
        };
        emit("load", {
          done
        });
        refreshing.value = true;
      } else {
        touchDiff.value = 0;
      }
    }
    onMounted(() => {
      scrollParents = getScrollParents(containerRef.value);
    });
    watch([topOffset, refreshing], () => {
      if (scrollParents.length) {
        const stopScrolling = topOffset.value && !refreshing.value;
        scrollParents.forEach((p) => p.style.overflow = stopScrolling ? "hidden" : "auto");
      }
    });
    watch(topOffset, (newVal, oldVal) => {
      goingUp.value = newVal < oldVal;
    });
    useRender(() => {
      return createBaseVNode("div", {
        "class": normalizeClass(["v-pull-to-refresh"]),
        "onTouchstart": onTouchstart,
        "onTouchmove": onTouchmove,
        "onTouchend": onTouchend,
        "onMousedown": onTouchstart,
        "onMouseup": onTouchend,
        "onMouseleave": onTouchend,
        "onMousemove": onTouchmove,
        "ref": containerRef
      }, [createBaseVNode("div", {
        "class": normalizeClass(["v-pull-to-refresh__pull-down", {
          "v-pull-to-refresh__pull-down--touching": touching.value
        }]),
        "style": {
          top: convertToUnit(-1 * props.pullDownThreshold + topOffset.value),
          height: convertToUnit(props.pullDownThreshold)
        }
      }, [slots.pullDownPanel ? slots.pullDownPanel({
        canRefresh: canRefresh.value,
        goingUp: goingUp.value,
        refreshing: refreshing.value
      }) : createBaseVNode("div", {
        "class": normalizeClass(["v-pull-to-refresh__pull-down-default"])
      }, [refreshing.value ? createVNode(VProgressCircular, {
        "indeterminate": true,
        "active": false
      }, null) : createVNode(VIcon, {
        "icon": canRefresh.value || goingUp.value ? "$sortAsc" : "$sortDesc"
      }, null)])]), createBaseVNode("div", {
        "class": normalizeClass(["v-pull-to-refresh__scroll-container", {
          "v-pull-to-refresh__scroll-container--touching": touching.value
        }]),
        "style": {
          top: convertToUnit(topOffset.value)
        }
      }, [slots.default?.()])]);
    });
  }
});

// node_modules/vuetify/lib/labs/VHotkey/VHotkey.js
import "C:/Users/islam/source/HRMS/client/node_modules/vuetify/lib/labs/VHotkey/VHotkey.css";
function processKey(config, requestedMode, isMac) {
  const keyCfg = isMac && config.mac ? config.mac : config.default;
  const mode = (() => {
    if (requestedMode === "icon" && !isMac) return "text";
    if (requestedMode === "icon" && !keyCfg.icon) return "text";
    if (requestedMode === "symbol" && !keyCfg.symbol) return "text";
    return requestedMode;
  })();
  let value = keyCfg[mode] ?? keyCfg.text;
  if (mode === "text" && typeof value === "string" && value.startsWith("$") && !value.startsWith("$vuetify.")) {
    value = value.slice(1).toUpperCase();
  }
  return mode === "icon" ? ["icon", value] : [mode, value];
}
var hotkeyMap = {
  ctrl: {
    mac: {
      symbol: "",
      icon: "$ctrl",
      text: "$vuetify.hotkey.ctrl"
    },
    default: {
      text: "Ctrl"
    }
  },
  meta: {
    mac: {
      symbol: "",
      icon: "$command",
      text: "$vuetify.hotkey.command"
    },
    default: {
      text: "Ctrl"
    }
  },
  cmd: {
    mac: {
      symbol: "",
      icon: "$command",
      text: "$vuetify.hotkey.command"
    },
    default: {
      text: "Ctrl"
    }
  },
  shift: {
    mac: {
      symbol: "",
      icon: "$shift",
      text: "$vuetify.hotkey.shift"
    },
    default: {
      text: "Shift"
    }
  },
  alt: {
    mac: {
      symbol: "",
      icon: "$alt",
      text: "$vuetify.hotkey.option"
    },
    default: {
      text: "Alt"
    }
  },
  enter: {
    default: {
      symbol: "",
      icon: "$enter",
      text: "$vuetify.hotkey.enter"
    }
  },
  arrowup: {
    default: {
      symbol: "",
      icon: "$arrowup",
      text: "$vuetify.hotkey.upArrow"
    }
  },
  arrowdown: {
    default: {
      symbol: "",
      icon: "$arrowdown",
      text: "$vuetify.hotkey.downArrow"
    }
  },
  arrowleft: {
    default: {
      symbol: "",
      icon: "$arrowleft",
      text: "$vuetify.hotkey.leftArrow"
    }
  },
  arrowright: {
    default: {
      symbol: "",
      icon: "$arrowright",
      text: "$vuetify.hotkey.rightArrow"
    }
  },
  backspace: {
    default: {
      symbol: "",
      icon: "$backspace",
      text: "$vuetify.hotkey.backspace"
    }
  },
  escape: {
    default: {
      text: "$vuetify.hotkey.escape"
    }
  },
  " ": {
    mac: {
      symbol: "",
      icon: "$space",
      text: "$vuetify.hotkey.space"
    },
    default: {
      text: "$vuetify.hotkey.space"
    }
  },
  "-": {
    default: {
      text: "-"
    }
  }
};
var makeVHotkeyVariantProps = propsFactory({
  variant: {
    type: String,
    default: "elevated",
    validator: (v) => ["elevated", "flat", "tonal", "outlined", "text", "plain", "contained"].includes(v)
  }
}, "VHotkeyVariant");
var makeVHotkeyProps = propsFactory({
  // String representing keyboard shortcuts (e.g., "ctrl+k", "meta+shift+p")
  keys: String,
  // How to display keys: 'symbol' uses special characters (, ), 'icon' uses SVG icons, 'text' uses words
  displayMode: {
    type: String,
    default: "icon"
  },
  // Custom key mapping configuration. Users can import and modify the exported hotkeyMap as needed
  keyMap: {
    type: Object,
    default: () => hotkeyMap
  },
  platform: {
    type: String,
    default: "auto"
  },
  inline: Boolean,
  disabled: Boolean,
  prefix: String,
  suffix: String,
  ...makeComponentProps(),
  ...makeThemeProps(),
  ...makeBorderProps(),
  ...makeRoundedProps(),
  ...makeElevationProps(),
  ...makeVHotkeyVariantProps(),
  color: String
}, "VHotkey");
var Delineator = class {
  constructor(delineator) {
    if (["and", "then"].includes(delineator)) this.val = delineator;
    else {
      throw new Error("Not a valid delineator");
    }
  }
  isEqual(d) {
    return this.val === d.val;
  }
};
function isDelineator(value) {
  return value instanceof Delineator;
}
function isString(value) {
  return typeof value === "string";
}
function getKeyText(keyMap, key, isMac) {
  const lowerKey = key.toLowerCase();
  if (lowerKey in keyMap) {
    const result = processKey(keyMap[lowerKey], "text", isMac);
    return typeof result[1] === "string" ? result[1] : String(result[1]);
  }
  return key.toUpperCase();
}
function applyDisplayModeToKey(keyMap, mode, key, isMac) {
  const lowerKey = key.toLowerCase();
  if (lowerKey in keyMap) {
    const result = processKey(keyMap[lowerKey], mode, isMac);
    if (result[0] === "text" && typeof result[1] === "string" && result[1].startsWith("$") && !result[1].startsWith("$vuetify.")) {
      return ["text", result[1].replace("$", "").toUpperCase(), key];
    }
    return [...result, key];
  }
  return ["text", key.toUpperCase(), key];
}
var VHotkey = genericComponent()({
  name: "VHotkey",
  props: makeVHotkeyProps(),
  setup(props) {
    const {
      t
    } = useLocale();
    const {
      themeClasses
    } = provideTheme(props);
    const {
      rtlClasses
    } = useRtl();
    const {
      borderClasses
    } = useBorder(props);
    const {
      roundedClasses
    } = useRounded(props);
    const {
      elevationClasses
    } = useElevation(props);
    const isContainedVariant = computed(() => props.variant === "contained");
    const effectiveVariantProps = computed(() => ({
      ...props,
      variant: isContainedVariant.value ? "elevated" : props.variant
    }));
    const {
      colorClasses,
      colorStyles,
      variantClasses
    } = useVariant(effectiveVariantProps);
    const isMac = computed(() => props.platform === "auto" ? typeof navigator !== "undefined" && /macintosh/i.test(navigator.userAgent) : props.platform === "mac");
    const effectiveDisplayMode = computed(() => props.displayMode);
    const AND_DELINEATOR = new Delineator("and");
    const THEN_DELINEATOR = new Delineator("then");
    const effectiveKeyMap = computed(() => props.keyMap);
    const keyCombinations = computed(() => {
      if (!props.keys) return [];
      return props.keys.split(" ").map((combination) => {
        const sequenceGroups = splitKeySequence(combination);
        return sequenceGroups.flatMap((group, groupIndex) => {
          const keyParts = splitKeyCombination(group);
          const parts = keyParts.reduce((acc, part, index) => {
            if (index !== 0) {
              return [...acc, AND_DELINEATOR, part];
            }
            return [...acc, part];
          }, []);
          const result = parts.map((key) => {
            if (isString(key)) {
              return applyDisplayModeToKey(effectiveKeyMap.value, effectiveDisplayMode.value, key, isMac.value);
            }
            return key;
          });
          if (groupIndex < sequenceGroups.length - 1) {
            result.push(THEN_DELINEATOR);
          }
          return result;
        });
      });
    });
    const accessibleLabel = computed(() => {
      if (!props.keys) return "";
      const readableShortcuts = keyCombinations.value.map((combination) => {
        const readableParts = [];
        for (const key of combination) {
          if (isDelineator(key)) {
            if (AND_DELINEATOR.isEqual(key)) {
              readableParts.push(t("$vuetify.hotkey.plus"));
            } else if (THEN_DELINEATOR.isEqual(key)) {
              readableParts.push(t("$vuetify.hotkey.then"));
            }
          } else {
            const textKey = key[0] === "icon" || key[0] === "symbol" ? applyDisplayModeToKey(mergeDeep(hotkeyMap, props.keyMap), "text", String(key[1]), isMac.value)[1] : key[1];
            readableParts.push(translateKey(textKey));
          }
        }
        return readableParts.join(" ");
      });
      const shortcutText = readableShortcuts.join(", ");
      return t("$vuetify.hotkey.shortcut", shortcutText);
    });
    function translateKey(key) {
      return key.startsWith("$vuetify.") ? t(key) : key;
    }
    function getKeyTooltip(key) {
      if (effectiveDisplayMode.value === "text") return void 0;
      const textKey = getKeyText(effectiveKeyMap.value, String(key[2]), isMac.value);
      return translateKey(textKey);
    }
    function renderKey(key, keyIndex, isContained) {
      const KeyComponent = isContained ? "kbd" : VKbd;
      const keyClasses = ["v-hotkey__key", `v-hotkey__key-${key[0]}`, ...isContained ? ["v-hotkey__key--nested"] : [borderClasses.value, roundedClasses.value, elevationClasses.value, colorClasses.value]];
      return createVNode(KeyComponent, {
        "key": keyIndex,
        "class": normalizeClass(keyClasses),
        "style": normalizeStyle(isContained ? void 0 : colorStyles.value),
        "aria-hidden": "true",
        "title": getKeyTooltip(key)
      }, {
        default: () => [key[0] === "icon" ? createVNode(VIcon, {
          "icon": key[1],
          "aria-hidden": "true"
        }, null) : translateKey(key[1])]
      });
    }
    function renderDivider(key, keyIndex) {
      return createBaseVNode("span", {
        "key": keyIndex,
        "class": "v-hotkey__divider",
        "aria-hidden": "true"
      }, [AND_DELINEATOR.isEqual(key) ? "+" : t("$vuetify.hotkey.then")]);
    }
    useRender(() => createBaseVNode("div", {
      "class": normalizeClass(["v-hotkey", {
        "v-hotkey--disabled": props.disabled,
        "v-hotkey--inline": props.inline,
        "v-hotkey--contained": isContainedVariant.value
      }, themeClasses.value, rtlClasses.value, variantClasses.value, props.class]),
      "style": normalizeStyle(props.style),
      "role": "img",
      "aria-label": accessibleLabel.value
    }, [isContainedVariant.value ? createVNode(VKbd, {
      "key": "contained",
      "class": normalizeClass(["v-hotkey__contained-wrapper", borderClasses.value, roundedClasses.value, elevationClasses.value, colorClasses.value]),
      "style": normalizeStyle(colorStyles.value),
      "aria-hidden": "true"
    }, {
      default: () => [props.prefix && createBaseVNode("span", {
        "key": "contained-prefix",
        "class": "v-hotkey__prefix"
      }, [props.prefix]), keyCombinations.value.map((combination, comboIndex) => createBaseVNode("span", {
        "class": "v-hotkey__combination",
        "key": comboIndex
      }, [combination.map((key, keyIndex) => isDelineator(key) ? renderDivider(key, keyIndex) : renderKey(key, keyIndex, true)), comboIndex < keyCombinations.value.length - 1 && createBaseVNode("span", {
        "aria-hidden": "true"
      }, [createTextVNode("")])])), props.suffix && createBaseVNode("span", {
        "key": "contained-suffix",
        "class": "v-hotkey__suffix"
      }, [props.suffix])]
    }) : createBaseVNode(Fragment, null, [props.prefix && createBaseVNode("span", {
      "key": "prefix",
      "class": "v-hotkey__prefix"
    }, [props.prefix]), keyCombinations.value.map((combination, comboIndex) => createBaseVNode("span", {
      "class": "v-hotkey__combination",
      "key": comboIndex
    }, [combination.map((key, keyIndex) => isDelineator(key) ? renderDivider(key, keyIndex) : renderKey(key, keyIndex, false)), comboIndex < keyCombinations.value.length - 1 && createBaseVNode("span", {
      "aria-hidden": "true"
    }, [createTextVNode("")])])), props.suffix && createBaseVNode("span", {
      "key": "suffix",
      "class": "v-hotkey__suffix"
    }, [props.suffix])])]));
  }
});

// node_modules/vuetify/lib/labs/VVideo/VVideo.js
import "C:/Users/islam/source/HRMS/client/node_modules/vuetify/lib/labs/VVideo/VVideo.css";

// node_modules/vuetify/lib/labs/VVideo/VVideoVolume.js
var makeVVideoVolumeProps = propsFactory({
  inline: Boolean,
  label: String,
  direction: {
    type: String,
    default: "vertical"
  },
  modelValue: {
    type: Number,
    default: 0
  },
  menuProps: Object,
  sliderProps: Object,
  onClick: EventProp(),
  ...makeComponentProps()
}, "VVideoVolume");
var VVideoVolume = genericComponent()({
  name: "VVideoVolume",
  directives: {
    vTooltip: tooltip_default
  },
  props: makeVVideoVolumeProps(),
  emits: {
    "update:modelValue": (val) => true
  },
  setup(props, _ref) {
    let {
      attrs
    } = _ref;
    const {
      t
    } = useLocale();
    const volume = useProxiedModel(props, "modelValue");
    const volumeIcon = toRef(() => volume.value > 70 ? "$volumeHigh" : volume.value > 40 ? "$volumeMedium" : volume.value > 10 ? "$volumeLow" : "$volumeOff");
    const containerRef = ref();
    useRender(() => {
      const sliderDefaults = {
        hideDetails: true,
        step: 5,
        thumbSize: 16
      };
      return createBaseVNode("div", {
        "class": normalizeClass(["v-video-volume", {
          "v-video-volume--inline": props.inline
        }, props.class]),
        "style": normalizeStyle(props.style),
        "ref": containerRef
      }, [withDirectives(createVNode(VIconBtn, mergeProps({
        "icon": volumeIcon.value,
        "aria-label": props.label,
        "onClick": props.onClick
      }, attrs), {
        default: () => [createVNode(VIcon, null, null), !props.inline && createVNode(VMenu, {
          "offset": "8",
          "activator": "parent",
          "attach": containerRef.value,
          "location": props.menuProps?.location ?? "top center",
          "closeOnContentClick": false
        }, {
          default: () => [createBaseVNode("div", {
            "class": normalizeClass(["v-video-volume__menu", `v-video-volume__menu--${props.direction}`])
          }, [createVNode(VSlider, mergeProps({
            "direction": props.direction,
            "aria-label": t("$vuetify.video.volume"),
            "modelValue": volume.value,
            "onUpdate:modelValue": (v) => volume.value = v
          }, sliderDefaults, props.sliderProps), null)])]
        })]
      }), [[tooltip_default, props.label, "top"]]), props.inline && createVNode(VSlider, mergeProps({
        "class": "v-video-volume-inline__slider",
        "minWidth": "50",
        "aria-label": t("$vuetify.video.volume"),
        "modelValue": volume.value,
        "onUpdate:modelValue": (v) => volume.value = v,
        "onKeydown": (e) => {
          e.stopPropagation();
        }
      }, sliderDefaults, props.sliderProps), null)]);
    });
  }
});

// node_modules/vuetify/lib/labs/VVideo/VVideoControls.js
var allowedVariants = ["hidden", "default", "tube", "mini"];
var makeVVideoControlsProps = propsFactory({
  color: String,
  backgroundColor: String,
  trackColor: String,
  playing: Boolean,
  hidePlay: Boolean,
  hideVolume: Boolean,
  hideFullscreen: Boolean,
  fullscreen: Boolean,
  floating: Boolean,
  splitTime: Boolean,
  pills: Boolean,
  detached: Boolean,
  progress: {
    type: Number,
    default: 0
  },
  duration: {
    type: Number,
    default: 0
  },
  volume: [Number, String],
  variant: {
    type: String,
    default: "default",
    validator: (v) => allowedVariants.includes(v)
  },
  volumeProps: Object,
  ...makeDensityProps(),
  ...makeElevationProps(),
  ...makeThemeProps()
}, "VVideoControls");
var VVideoControls = genericComponent()({
  name: "VVideoControls",
  directives: {
    vTooltip: tooltip_default
  },
  props: makeVVideoControlsProps(),
  emits: {
    "update:playing": (val) => true,
    "update:progress": (val) => true,
    "update:volume": (val) => true,
    skip: (val) => true,
    "click:fullscreen": () => true
  },
  setup(props, _ref) {
    let {
      emit,
      slots
    } = _ref;
    const {
      t
    } = useLocale();
    const {
      themeClasses,
      current: currentTheme
    } = provideTheme(props);
    const {
      densityClasses
    } = useDensity(props);
    const {
      elevationClasses
    } = useElevation(props);
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(() => {
      const fallbackBackground = props.detached ? "surface" : void 0;
      return props.backgroundColor ?? fallbackBackground;
    });
    const trackColor = toRef(() => {
      if (props.trackColor) {
        return props.trackColor;
      }
      const fallback = currentTheme.value.dark || !props.pills ? void 0 : "surface";
      return (props.pills ? props.backgroundColor : props.color) ?? fallback;
    });
    const playing = useProxiedModel(props, "playing");
    const progress = useProxiedModel(props, "progress");
    const volume = useProxiedModel(props, "volume", 0, (v) => Number(v ?? 0));
    const lastVolume = shallowRef();
    const currentTime = computed(() => {
      const secondsElapsed = Math.round(props.progress / 100 * props.duration);
      return {
        elapsed: formatTime(secondsElapsed),
        remaining: formatTime(props.duration - secondsElapsed),
        total: formatTime(props.duration)
      };
    });
    const labels = computed(() => {
      const playIconLocaleKey = playing.value ? "pause" : "play";
      const volumeIconLocaleKey = props.volumeProps?.inline ? volume.value ? "mute" : "unmute" : "showVolume";
      const fullscreenIconLocaleKey = props.fullscreen ? "exitFullscreen" : "enterFullscreen";
      return {
        seek: t("$vuetify.video.seek"),
        volume: t("$vuetify.video.volume"),
        playAction: t(`$vuetify.video.${playIconLocaleKey}`),
        volumeAction: t(`$vuetify.video.${volumeIconLocaleKey}`),
        fullscreenAction: t(`$vuetify.video.${fullscreenIconLocaleKey}`)
      };
    });
    function play() {
      playing.value = true;
    }
    function pause() {
      playing.value = false;
    }
    function skipTo(v) {
      progress.value = v;
    }
    function toggleMuted() {
      if (volume.value) {
        lastVolume.value = volume.value;
        volume.value = 0;
      } else {
        volume.value = lastVolume.value ?? 100;
      }
    }
    function toggleFullscreen() {
      emit("click:fullscreen");
    }
    useRender(() => {
      const sizes = props.pills ? [42, 36, 30] : [32, 28, 24];
      const innerDefaults = {
        VIconBtn: {
          size: props.density === "compact" ? sizes[2] : props.density === "comfortable" ? sizes[1] : sizes[0],
          iconSize: props.density === "compact" ? 20 : props.density === "comfortable" ? 24 : 26,
          variant: "text",
          color: props.color
        },
        VSlider: {
          thumbSize: props.variant === "tube" ? 10 : 16,
          hideDetails: true
        }
      };
      const regularBtnSize = innerDefaults.VIconBtn.size;
      const playBtnSize = props.pills ? regularBtnSize + 8 : regularBtnSize;
      const pillClasses = ["v-video-control__pill", props.pills ? elevationClasses.value : [], props.pills ? backgroundColorClasses.value : []];
      const pillStyles = props.pills ? backgroundColorStyles.value : [];
      const slotProps = {
        play,
        pause,
        playing: playing.value,
        progress: progress.value,
        currentTime: currentTime.value,
        skipTo,
        volume,
        toggleMuted,
        fullscreen: props.fullscreen,
        toggleFullscreen,
        labels: labels.value
      };
      return createBaseVNode("div", {
        "class": normalizeClass(["v-video-controls", `v-video-controls--variant-${props.variant}`, {
          "v-video-controls--pills": props.pills
        }, {
          "v-video-controls--detached": props.detached
        }, {
          "v-video-controls--floating": props.floating
        }, {
          "v-video-controls--split-time": props.splitTime
        }, !props.pills ? backgroundColorClasses.value : [], props.detached && !props.pills ? elevationClasses.value : [], densityClasses.value, themeClasses.value]),
        "style": normalizeStyle([!props.pills ? backgroundColorStyles.value : [], {
          "--v-video-controls-pill-height": `${regularBtnSize}px`
        }])
      }, [createVNode(VDefaultsProvider, {
        "defaults": innerDefaults
      }, {
        default: () => [slots.default?.(slotProps) ?? createBaseVNode(Fragment, null, [props.variant !== "mini" && createBaseVNode(Fragment, null, [!props.hidePlay && createBaseVNode("div", {
          "class": normalizeClass([pillClasses, "v-video__action-play"]),
          "style": normalizeStyle(pillStyles)
        }, [withDirectives(createVNode(VIconBtn, {
          "icon": playing.value ? "$pause" : "$play",
          "size": playBtnSize,
          "aria-label": labels.value.playAction,
          "onClick": () => playing.value = !playing.value
        }, null), [[tooltip_default, labels.value.playAction, "top"]])]), slots.prepend && createBaseVNode("div", {
          "class": normalizeClass(pillClasses),
          "style": normalizeStyle(pillStyles)
        }, [slots.prepend(slotProps)]), props.splitTime ? createBaseVNode("span", {
          "class": normalizeClass([pillClasses, "v-video__time"]),
          "style": normalizeStyle(pillStyles)
        }, [currentTime.value.elapsed]) : props.variant !== "default" ? createBaseVNode("span", {
          "class": normalizeClass([pillClasses, "v-video__time"]),
          "style": normalizeStyle(pillStyles)
        }, [currentTime.value.elapsed, createTextVNode(" / "), currentTime.value.total]) : "", createVNode(VSlider, {
          "modelValue": props.progress,
          "noKeyboard": true,
          "color": trackColor.value ?? "surface-variant",
          "trackColor": props.variant === "tube" ? "white" : void 0,
          "class": "v-video__track",
          "thumbLabel": "always",
          "aria-label": labels.value.seek,
          "onUpdate:modelValue": skipTo
        }, {
          "thumb-label": () => currentTime.value.elapsed
        }), props.variant === "tube" && createVNode(VSpacer, null, null), props.splitTime ? createBaseVNode("span", {
          "class": normalizeClass([pillClasses, "v-video__time"]),
          "style": normalizeStyle(pillStyles)
        }, [currentTime.value.remaining]) : ""]), props.variant === "mini" && createBaseVNode(Fragment, null, [createVNode(VSpacer, null, null), slots.prepend && createBaseVNode("div", {
          "class": normalizeClass(pillClasses),
          "style": normalizeStyle(pillStyles)
        }, [slots.prepend(slotProps)]), !props.hidePlay && createBaseVNode("div", {
          "class": normalizeClass([pillClasses, "v-video__action-play"]),
          "style": normalizeStyle(pillStyles)
        }, [withDirectives(createVNode(VIconBtn, {
          "icon": playing.value ? "$pause" : "$play",
          "size": playBtnSize,
          "aria-label": labels.value.playAction,
          "onClick": () => playing.value = !playing.value
        }, null), [[tooltip_default, labels.value.playAction, "top"]])])]), (!props.hideVolume || !props.hideFullscreen || slots.append) && createBaseVNode("div", {
          "class": normalizeClass(pillClasses),
          "style": normalizeStyle(pillStyles)
        }, [!props.hideVolume && createVNode(VVideoVolume, mergeProps({
          "key": "volume-control",
          "sliderProps": {
            color: props.color
          },
          "modelValue": volume.value,
          "label": labels.value.volumeAction,
          "onUpdate:modelValue": (v) => volume.value = v,
          "onClick": () => props.volumeProps?.inline && toggleMuted()
        }, props.volumeProps), null), slots.append?.(slotProps), !props.hideFullscreen && withDirectives(createVNode(VIconBtn, {
          "icon": props.fullscreen ? "$fullscreenExit" : "$fullscreen",
          "aria-label": labels.value.fullscreenAction,
          "onClick": toggleFullscreen
        }, null), [[tooltip_default, labels.value.fullscreenAction, "top"]])]), props.variant === "mini" && createVNode(VSpacer, null, null)])]
      })]);
    });
    return {
      toggleMuted
    };
  }
});

// node_modules/vuetify/lib/labs/VVideo/VVideo.js
var allowedVariants2 = ["background", "player"];
var makeVVideoProps = propsFactory({
  aspectRatio: [String, Number],
  autoplay: Boolean,
  muted: Boolean,
  eager: Boolean,
  src: String,
  type: String,
  // e.g. video/mp4
  image: String,
  hideOverlay: Boolean,
  noFullscreen: Boolean,
  startAt: [Number, String],
  variant: {
    type: String,
    default: "player",
    validator: (v) => allowedVariants2.includes(v)
  },
  controlsTransition: {
    type: [Boolean, String, Object],
    component: VFadeTransition
  },
  controlsVariant: {
    type: String,
    default: "default"
  },
  controlsProps: {
    type: Object
  },
  rounded: [Boolean, Number, String, Array],
  ...makeComponentProps(),
  ...makeDensityProps(),
  ...makeDimensionProps(),
  ...makeThemeProps(),
  ...omit(makeVVideoControlsProps(), ["fullscreen", "variant"])
}, "VVideo");
var VVideo = genericComponent()({
  name: "VVideo",
  inheritAttrs: false,
  props: makeVVideoProps(),
  emits: {
    loaded: (element) => true,
    "update:playing": (val) => true,
    "update:progress": (val) => true,
    "update:volume": (val) => true
  },
  setup(props, _ref) {
    let {
      attrs,
      emit,
      slots
    } = _ref;
    const {
      themeClasses
    } = provideTheme(props);
    const {
      densityClasses
    } = useDensity(props);
    const {
      dimensionStyles
    } = useDimension(props);
    const {
      elevationClasses
    } = useElevation(props);
    const {
      ssr
    } = useDisplay();
    const roundedForContainer = toRef(() => Array.isArray(props.rounded) ? props.rounded[0] : props.rounded);
    const roundedForControls = toRef(() => Array.isArray(props.rounded) ? props.rounded.at(-1) : props.rounded ?? false);
    const {
      roundedClasses: roundedContainerClasses
    } = useRounded(roundedForContainer);
    const {
      roundedClasses: roundedControlsClasses
    } = useRounded(roundedForControls);
    const containerRef = ref();
    const videoRef = ref();
    const controlsRef = ref();
    const playing = useProxiedModel(props, "playing");
    const progress = useProxiedModel(props, "progress");
    const volume = useProxiedModel(props, "volume", 0, (v) => Number(v ?? 0));
    const fullscreen = shallowRef(false);
    const waiting = shallowRef(false);
    const triggered = shallowRef(false);
    const startAfterLoad = shallowRef(false);
    const state = shallowRef(props.autoplay ? "loading" : "idle");
    const duration = shallowRef(0);
    const fullscreenEnabled = toRef(() => !props.noFullscreen && !String(attrs.controlsList ?? "").includes("nofullscreen"));
    function onTimeupdate() {
      const {
        currentTime,
        duration: duration2
      } = videoRef.value;
      progress.value = duration2 === 0 ? 0 : 100 * currentTime / duration2;
    }
    async function onTriggered() {
      await nextTick();
      if (!videoRef.value) return;
      videoRef.value.addEventListener("timeupdate", onTimeupdate);
      videoRef.value.volume = volume.value / 100;
      if (state.value !== "loaded") {
        state.value = "loading";
      }
    }
    function onVideoLoaded() {
      state.value = "loaded";
      duration.value = videoRef.value.duration;
      const startTime = Number(props.startAt ?? 0);
      if (startTime && startTime <= duration.value) {
        videoRef.value.currentTime = startTime;
        progress.value = duration.value === 0 ? 0 : 100 * startTime / duration.value;
      }
      if (startAfterLoad.value) {
        setTimeout(() => playing.value = true, 100);
      }
      emit("loaded", videoRef.value);
    }
    function onClick() {
      if (state.value !== "loaded") {
        triggered.value = true;
        startAfterLoad.value = !startAfterLoad.value;
      }
    }
    function onKeydown(e) {
      if (!videoRef.value || e.ctrlKey) return;
      if (e.key.startsWith("Arrow")) {
        e.preventDefault();
      }
      switch (true) {
        case e.key === " ": {
          if (!["A", "BUTTON"].includes(e.target?.tagName)) {
            e.preventDefault();
            playing.value = !playing.value;
          }
          break;
        }
        case e.key === "ArrowRight": {
          const step = 10 * (e.shiftKey ? 6 : 1);
          videoRef.value.currentTime = Math.min(videoRef.value.currentTime + step, duration.value);
          break;
        }
        case e.key === "ArrowLeft": {
          const step = 10 * (e.shiftKey ? 6 : 1);
          videoRef.value.currentTime = Math.max(videoRef.value.currentTime - step, 0);
          break;
        }
        case createRange(10).map(String).includes(e.key): {
          skipTo(Number(e.key) * 10);
          break;
        }
        case e.key === "ArrowUp": {
          volume.value = Math.min(volume.value + 10, 100);
          break;
        }
        case e.key === "ArrowDown": {
          volume.value = Math.max(volume.value - 10, 0);
          break;
        }
        case e.key === "m": {
          controlsRef.value?.toggleMuted();
          break;
        }
        case e.key === "f": {
          toggleFullscreen();
          break;
        }
      }
    }
    function skipTo(v) {
      if (!videoRef.value) return;
      progress.value = v;
      videoRef.value.currentTime = duration.value * v / 100;
    }
    watch(() => props.src, (v) => {
      progress.value = 0;
    });
    watch(playing, (v) => {
      if (!videoRef.value) return;
      if (v) {
        videoRef.value.play();
      } else {
        videoRef.value.pause();
      }
    });
    watch(volume, (v) => {
      if (!videoRef.value) return;
      videoRef.value.volume = v / 100;
    });
    watch(triggered, () => onTriggered(), {
      once: true
    });
    watch(() => props.eager, (v) => v && (triggered.value = true), {
      immediate: true
    });
    onMounted(() => {
      if (props.autoplay && !ssr) {
        triggered.value = true;
        startAfterLoad.value = true;
      }
    });
    onBeforeUnmount(() => {
      videoRef.value?.removeEventListener("timeupdate", onTimeupdate);
    });
    function focusSlider() {
      const container = videoRef.value?.closest(".v-video");
      const innerSlider = container?.querySelector('[role="slider"]');
      innerSlider?.focus();
    }
    function fullscreenExitShortcut(e) {
      if (["ESC", "f"].includes(e.key)) {
        toggleFullscreen();
        document.body.removeEventListener("keydown", fullscreenExitShortcut);
      }
    }
    async function toggleFullscreen() {
      if (!fullscreenEnabled.value || !document.fullscreenEnabled) {
        return;
      }
      if (document.fullscreenElement) {
        document.exitFullscreen();
        onFullscreenExit();
      } else {
        await containerRef.value?.requestFullscreen();
        document.body.addEventListener("keydown", fullscreenExitShortcut);
        document.addEventListener("fullscreenchange", onFullscreenExit);
        fullscreen.value = true;
      }
    }
    function onFullscreenExit() {
      if (document.fullscreenElement) return;
      focusSlider();
      fullscreen.value = false;
      document.body.removeEventListener("keydown", fullscreenExitShortcut);
      document.removeEventListener("fullscreenchange", onFullscreenExit);
    }
    function onVideoClick(e) {
      e.preventDefault();
      if (state.value === "loaded") {
        playing.value = !playing.value;
        focusSlider();
      }
    }
    function onDoubleClick(e) {
      e.preventDefault();
      toggleFullscreen();
    }
    let lastTap = 0;
    function onTouchend(e) {
      const now = performance.now();
      if (now - lastTap < 500) {
        e.preventDefault();
        toggleFullscreen();
      } else {
        lastTap = now;
      }
    }
    useRender(() => {
      const showControls = state.value === "loaded" && props.variant === "player" && props.controlsVariant !== "hidden";
      const posterTransition = props.variant === "background" ? "poster-fade-out" : "fade-transition";
      const controlsProps = {
        ...VVideoControls.filterProps(omit(props, ["variant", "rounded", "hideVolume"])),
        rounded: Array.isArray(props.rounded) ? props.rounded.at(-1) : props.rounded,
        fullscreen: fullscreen.value,
        hideVolume: props.hideVolume || props.muted,
        hideFullscreen: props.hideFullscreen || !fullscreenEnabled.value,
        density: props.density,
        variant: props.controlsVariant,
        playing: playing.value,
        progress: progress.value,
        duration: duration.value,
        volume: volume.value,
        ...props.controlsProps
      };
      const controlsEventHandlers = {
        onSkip: (v) => skipTo(v),
        "onClick:fullscreen": () => toggleFullscreen(),
        "onUpdate:playing": (v) => playing.value = v,
        "onUpdate:progress": (v) => skipTo(v),
        "onUpdate:volume": (v) => volume.value = v,
        onClick: (e) => e.stopPropagation()
      };
      const controlslist = [attrs.controlslist, props.noFullscreen ? "nofullscreen" : ""].filter(Boolean).join(" ");
      const loadingIndicator = createVNode(VProgressCircular, {
        "indeterminate": true,
        "color": props.color,
        "width": "3",
        "size": Math.min(100, Number(props.height) / 2 || 50)
      }, null);
      const overlayPlayIcon = createVNode(VIconBtn, {
        "icon": "$play",
        "size": "80",
        "color": "#fff",
        "variant": "outlined",
        "iconSize": "50",
        "class": "v-video__center-icon",
        "onClick": onVideoClick
      }, null);
      const activeOverlays = {
        playIcon: props.variant === "player" && state.value === "loaded" && !props.hideOverlay && !playing.value,
        poster: state.value !== "loaded",
        loading: props.variant === "player" && (state.value === "loading" || waiting.value)
      };
      return createBaseVNode("div", {
        "ref": containerRef,
        "class": normalizeClass(["v-video", `v-video--variant-${props.variant}`, `v-video--${state.value}`, {
          "v-video--playing": playing.value
        }, themeClasses.value, densityClasses.value, roundedContainerClasses.value, props.class]),
        "style": normalizeStyle([{
          "--v-video-aspect-ratio": props.aspectRatio
        }, props.variant === "background" ? [] : pick(dimensionStyles.value, ["width", "minWidth", "maxWidth"]), props.style]),
        "onKeydown": onKeydown,
        "onClick": onClick
      }, [createBaseVNode("div", {
        "class": normalizeClass(["v-video__content", elevationClasses.value]),
        "style": normalizeStyle([props.variant === "background" ? [] : dimensionStyles.value])
      }, [(props.eager || triggered.value) && createBaseVNode("video", mergeProps({
        "key": "video-element",
        "class": ["v-video__video", roundedContainerClasses.value]
      }, omit(attrs, ["controlslist", "class", "style"]), {
        "controlslist": controlslist,
        "autoplay": props.autoplay,
        "muted": props.muted,
        "playsinline": true,
        "ref": videoRef,
        "onLoadeddata": onVideoLoaded,
        "onPlay": () => playing.value = true,
        "onPause": () => playing.value = false,
        "onWaiting": () => waiting.value = true,
        "onPlaying": () => waiting.value = false,
        "onClick": onVideoClick,
        "onDblclick": onDoubleClick,
        "onTouchend": onTouchend
      }), [slots.sources?.() ?? createBaseVNode("source", {
        "src": props.src,
        "type": props.type
      }, null)]), createVNode(Transition, {
        "name": "fade-transition"
      }, {
        default: () => [activeOverlays.playIcon && createBaseVNode("div", {
          "class": "v-video__overlay-fill"
        }, [overlayPlayIcon])]
      }), props.variant === "player" && !!slots.header && createBaseVNode("div", {
        "key": "header",
        "class": "v-video__header"
      }, [slots.header()]), createVNode(MaybeTransition, {
        "transition": posterTransition
      }, {
        default: () => [activeOverlays.poster && createBaseVNode("div", {
          "class": "v-video__overlay-fill"
        }, [createVNode(VImg, {
          "cover": true,
          "src": props.image
        }, {
          default: () => [createBaseVNode("div", {
            "class": normalizeClass(["v-video__overlay-fill", ...roundedContainerClasses.value])
          }, [props.variant === "player" && overlayPlayIcon])]
        })])]
      }), activeOverlays.loading && createBaseVNode("div", {
        "class": "v-video__overlay-fill"
      }, [loadingIndicator])]), createVNode(MaybeTransition, {
        "key": "actions",
        "transition": props.controlsTransition
      }, {
        default: () => [showControls && createVNode(VVideoControls, mergeProps({
          "ref": controlsRef,
          "class": roundedControlsClasses.value
        }, controlsProps, controlsEventHandlers), {
          default: slots.controls,
          prepend: slots.prepend,
          append: slots.append
        })]
      })]);
    });
    return {
      video: videoRef,
      ...forwardRefs({
        skipTo,
        toggleFullscreen
      }, controlsRef)
    };
  }
});
export {
  VCalendar,
  VColorInput,
  VDateInput,
  VFileUpload,
  VFileUploadItem,
  VHotkey,
  VIconBtn,
  VMaskInput,
  VPicker,
  VPickerTitle,
  VPie,
  VPieSegment,
  VPieTooltip,
  VPullToRefresh,
  VStepperVertical,
  VStepperVerticalActions,
  VStepperVerticalItem,
  VVideo,
  VVideoControls,
  VVideoVolume
};
//# sourceMappingURL=vuetify_labs_components.js.map
